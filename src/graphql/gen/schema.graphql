schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "Account"
"""
type Account {
  db_write_timestamp: timestamp
  id: String!

  """An array relationship"""
  loans(
    """distinct select on columns"""
    distinct_on: [Loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Loan_order_by!]

    """filter the rows returned"""
    where: Loan_bool_exp
  ): [Loan!]!

  """An array relationship"""
  marketsCreated(
    """distinct select on columns"""
    distinct_on: [Market_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Market_order_by!]

    """filter the rows returned"""
    where: Market_bool_exp
  ): [Market!]!

  """An array relationship"""
  presaleParticipations(
    """distinct select on columns"""
    distinct_on: [PresaleParticipation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleParticipation_order_by!]

    """filter the rows returned"""
    where: PresaleParticipation_bool_exp
  ): [PresaleParticipation!]!

  """An array relationship"""
  stakes(
    """distinct select on columns"""
    distinct_on: [Stake_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Stake_order_by!]

    """filter the rows returned"""
    where: Stake_bool_exp
  ): [Stake!]!

  """An array relationship"""
  trades(
    """distinct select on columns"""
    distinct_on: [Trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Trade_order_by!]

    """filter the rows returned"""
    where: Trade_bool_exp
  ): [Trade!]!

  """An array relationship"""
  userMarketPositions(
    """distinct select on columns"""
    distinct_on: [UserMarketPosition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserMarketPosition_order_by!]

    """filter the rows returned"""
    where: UserMarketPosition_bool_exp
  ): [UserMarketPosition!]!
}

"""
Boolean expression to filter rows from the table "Account". All fields are combined with a logical 'AND'.
"""
input Account_bool_exp {
  _and: [Account_bool_exp!]
  _not: Account_bool_exp
  _or: [Account_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  loans: Loan_bool_exp
  marketsCreated: Market_bool_exp
  presaleParticipations: PresaleParticipation_bool_exp
  stakes: Stake_bool_exp
  trades: Trade_bool_exp
  userMarketPositions: UserMarketPosition_bool_exp
}

"""Ordering options when selecting data from "Account"."""
input Account_order_by {
  db_write_timestamp: order_by
  id: order_by
  loans_aggregate: Loan_aggregate_order_by
  marketsCreated_aggregate: Market_aggregate_order_by
  presaleParticipations_aggregate: PresaleParticipation_aggregate_order_by
  stakes_aggregate: Stake_aggregate_order_by
  trades_aggregate: Trade_aggregate_order_by
  userMarketPositions_aggregate: UserMarketPosition_aggregate_order_by
}

"""
select columns of table "Account"
"""
enum Account_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  id
}

"""
Streaming cursor of the table "Account"
"""
input Account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Account_stream_cursor_value_input {
  db_write_timestamp: timestamp
  id: String
}

"""
columns and relationships of "AuthorizerContract"
"""
type AuthorizerContract {
  createdAt: numeric!
  db_write_timestamp: timestamp
  floor: String!
  id: String!
  lastAssignedRoleId: numeric!
  lastUpdatedAt: numeric!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [Role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Role_order_by!]

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!
}

"""
Boolean expression to filter rows from the table "AuthorizerContract". All fields are combined with a logical 'AND'.
"""
input AuthorizerContract_bool_exp {
  _and: [AuthorizerContract_bool_exp!]
  _not: AuthorizerContract_bool_exp
  _or: [AuthorizerContract_bool_exp!]
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  floor: String_comparison_exp
  id: String_comparison_exp
  lastAssignedRoleId: numeric_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  roles: Role_bool_exp
}

"""Ordering options when selecting data from "AuthorizerContract"."""
input AuthorizerContract_order_by {
  createdAt: order_by
  db_write_timestamp: order_by
  floor: order_by
  id: order_by
  lastAssignedRoleId: order_by
  lastUpdatedAt: order_by
  roles_aggregate: Role_aggregate_order_by
}

"""
select columns of table "AuthorizerContract"
"""
enum AuthorizerContract_select_column {
  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  floor

  """column name"""
  id

  """column name"""
  lastAssignedRoleId

  """column name"""
  lastUpdatedAt
}

"""
Streaming cursor of the table "AuthorizerContract"
"""
input AuthorizerContract_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: AuthorizerContract_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input AuthorizerContract_stream_cursor_value_input {
  createdAt: numeric
  db_write_timestamp: timestamp
  floor: String
  id: String
  lastAssignedRoleId: numeric
  lastUpdatedAt: numeric
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "CreditFacilityContract"
"""
type CreditFacilityContract {
  borrowToken_id: String!
  collateralToken_id: String!
  createdAt: numeric!
  db_write_timestamp: timestamp
  id: String!
  lastUpdatedAt: numeric!

  """An array relationship"""
  loans(
    """distinct select on columns"""
    distinct_on: [Loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Loan_order_by!]

    """filter the rows returned"""
    where: Loan_bool_exp
  ): [Loan!]!
  market_id: String!
  totalDebtFormatted: String!
  totalDebtRaw: numeric!
  totalLoans: numeric!
  totalLockedCollateralFormatted: String!
  totalLockedCollateralRaw: numeric!
  totalVolumeFormatted: String!
  totalVolumeRaw: numeric!
}

"""
Boolean expression to filter rows from the table "CreditFacilityContract". All fields are combined with a logical 'AND'.
"""
input CreditFacilityContract_bool_exp {
  _and: [CreditFacilityContract_bool_exp!]
  _not: CreditFacilityContract_bool_exp
  _or: [CreditFacilityContract_bool_exp!]
  borrowToken_id: String_comparison_exp
  collateralToken_id: String_comparison_exp
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  loans: Loan_bool_exp
  market_id: String_comparison_exp
  totalDebtFormatted: String_comparison_exp
  totalDebtRaw: numeric_comparison_exp
  totalLoans: numeric_comparison_exp
  totalLockedCollateralFormatted: String_comparison_exp
  totalLockedCollateralRaw: numeric_comparison_exp
  totalVolumeFormatted: String_comparison_exp
  totalVolumeRaw: numeric_comparison_exp
}

"""Ordering options when selecting data from "CreditFacilityContract"."""
input CreditFacilityContract_order_by {
  borrowToken_id: order_by
  collateralToken_id: order_by
  createdAt: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  loans_aggregate: Loan_aggregate_order_by
  market_id: order_by
  totalDebtFormatted: order_by
  totalDebtRaw: order_by
  totalLoans: order_by
  totalLockedCollateralFormatted: order_by
  totalLockedCollateralRaw: order_by
  totalVolumeFormatted: order_by
  totalVolumeRaw: order_by
}

"""
select columns of table "CreditFacilityContract"
"""
enum CreditFacilityContract_select_column {
  """column name"""
  borrowToken_id

  """column name"""
  collateralToken_id

  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  market_id

  """column name"""
  totalDebtFormatted

  """column name"""
  totalDebtRaw

  """column name"""
  totalLoans

  """column name"""
  totalLockedCollateralFormatted

  """column name"""
  totalLockedCollateralRaw

  """column name"""
  totalVolumeFormatted

  """column name"""
  totalVolumeRaw
}

"""
Streaming cursor of the table "CreditFacilityContract"
"""
input CreditFacilityContract_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: CreditFacilityContract_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input CreditFacilityContract_stream_cursor_value_input {
  borrowToken_id: String
  collateralToken_id: String
  createdAt: numeric
  db_write_timestamp: timestamp
  id: String
  lastUpdatedAt: numeric
  market_id: String
  totalDebtFormatted: String
  totalDebtRaw: numeric
  totalLoans: numeric
  totalLockedCollateralFormatted: String
  totalLockedCollateralRaw: numeric
  totalVolumeFormatted: String
  totalVolumeRaw: numeric
}

"""
columns and relationships of "FeeSplitterPayment"
"""
type FeeSplitterPayment {
  amountFormatted: String!
  amountRaw: numeric!
  db_write_timestamp: timestamp
  id: String!
  isFloorFee: Boolean!
  market_id: String!
  recipient: String!
  timestamp: numeric!
  token_id: String!
  transactionHash: String!
  treasury_id: String!
}

"""
order by aggregate values of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_aggregate_order_by {
  avg: FeeSplitterPayment_avg_order_by
  count: order_by
  max: FeeSplitterPayment_max_order_by
  min: FeeSplitterPayment_min_order_by
  stddev: FeeSplitterPayment_stddev_order_by
  stddev_pop: FeeSplitterPayment_stddev_pop_order_by
  stddev_samp: FeeSplitterPayment_stddev_samp_order_by
  sum: FeeSplitterPayment_sum_order_by
  var_pop: FeeSplitterPayment_var_pop_order_by
  var_samp: FeeSplitterPayment_var_samp_order_by
  variance: FeeSplitterPayment_variance_order_by
}

"""
order by avg() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_avg_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "FeeSplitterPayment". All fields are combined with a logical 'AND'.
"""
input FeeSplitterPayment_bool_exp {
  _and: [FeeSplitterPayment_bool_exp!]
  _not: FeeSplitterPayment_bool_exp
  _or: [FeeSplitterPayment_bool_exp!]
  amountFormatted: String_comparison_exp
  amountRaw: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  isFloorFee: Boolean_comparison_exp
  market_id: String_comparison_exp
  recipient: String_comparison_exp
  timestamp: numeric_comparison_exp
  token_id: String_comparison_exp
  transactionHash: String_comparison_exp
  treasury_id: String_comparison_exp
}

"""
order by max() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_max_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  market_id: order_by
  recipient: order_by
  timestamp: order_by
  token_id: order_by
  transactionHash: order_by
  treasury_id: order_by
}

"""
order by min() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_min_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  market_id: order_by
  recipient: order_by
  timestamp: order_by
  token_id: order_by
  transactionHash: order_by
  treasury_id: order_by
}

"""Ordering options when selecting data from "FeeSplitterPayment"."""
input FeeSplitterPayment_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  isFloorFee: order_by
  market_id: order_by
  recipient: order_by
  timestamp: order_by
  token_id: order_by
  transactionHash: order_by
  treasury_id: order_by
}

"""
select columns of table "FeeSplitterPayment"
"""
enum FeeSplitterPayment_select_column {
  """column name"""
  amountFormatted

  """column name"""
  amountRaw

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  isFloorFee

  """column name"""
  market_id

  """column name"""
  recipient

  """column name"""
  timestamp

  """column name"""
  token_id

  """column name"""
  transactionHash

  """column name"""
  treasury_id
}

"""
order by stddev() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_stddev_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_stddev_pop_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_stddev_samp_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "FeeSplitterPayment"
"""
input FeeSplitterPayment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: FeeSplitterPayment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input FeeSplitterPayment_stream_cursor_value_input {
  amountFormatted: String
  amountRaw: numeric
  db_write_timestamp: timestamp
  id: String
  isFloorFee: Boolean
  market_id: String
  recipient: String
  timestamp: numeric
  token_id: String
  transactionHash: String
  treasury_id: String
}

"""
order by sum() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_sum_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_var_pop_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_var_samp_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "FeeSplitterPayment"
"""
input FeeSplitterPayment_variance_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
columns and relationships of "FeeSplitterReceipt"
"""
type FeeSplitterReceipt {
  amountFormatted: String!
  amountRaw: numeric!
  db_write_timestamp: timestamp
  id: String!
  market_id: String!
  sender: String!
  timestamp: numeric!
  token_id: String!
  transactionHash: String!
  treasury_id: String!
}

"""
order by aggregate values of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_aggregate_order_by {
  avg: FeeSplitterReceipt_avg_order_by
  count: order_by
  max: FeeSplitterReceipt_max_order_by
  min: FeeSplitterReceipt_min_order_by
  stddev: FeeSplitterReceipt_stddev_order_by
  stddev_pop: FeeSplitterReceipt_stddev_pop_order_by
  stddev_samp: FeeSplitterReceipt_stddev_samp_order_by
  sum: FeeSplitterReceipt_sum_order_by
  var_pop: FeeSplitterReceipt_var_pop_order_by
  var_samp: FeeSplitterReceipt_var_samp_order_by
  variance: FeeSplitterReceipt_variance_order_by
}

"""
order by avg() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_avg_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "FeeSplitterReceipt". All fields are combined with a logical 'AND'.
"""
input FeeSplitterReceipt_bool_exp {
  _and: [FeeSplitterReceipt_bool_exp!]
  _not: FeeSplitterReceipt_bool_exp
  _or: [FeeSplitterReceipt_bool_exp!]
  amountFormatted: String_comparison_exp
  amountRaw: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  market_id: String_comparison_exp
  sender: String_comparison_exp
  timestamp: numeric_comparison_exp
  token_id: String_comparison_exp
  transactionHash: String_comparison_exp
  treasury_id: String_comparison_exp
}

"""
order by max() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_max_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  market_id: order_by
  sender: order_by
  timestamp: order_by
  token_id: order_by
  transactionHash: order_by
  treasury_id: order_by
}

"""
order by min() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_min_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  market_id: order_by
  sender: order_by
  timestamp: order_by
  token_id: order_by
  transactionHash: order_by
  treasury_id: order_by
}

"""Ordering options when selecting data from "FeeSplitterReceipt"."""
input FeeSplitterReceipt_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  market_id: order_by
  sender: order_by
  timestamp: order_by
  token_id: order_by
  transactionHash: order_by
  treasury_id: order_by
}

"""
select columns of table "FeeSplitterReceipt"
"""
enum FeeSplitterReceipt_select_column {
  """column name"""
  amountFormatted

  """column name"""
  amountRaw

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  market_id

  """column name"""
  sender

  """column name"""
  timestamp

  """column name"""
  token_id

  """column name"""
  transactionHash

  """column name"""
  treasury_id
}

"""
order by stddev() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_stddev_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_stddev_pop_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_stddev_samp_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: FeeSplitterReceipt_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input FeeSplitterReceipt_stream_cursor_value_input {
  amountFormatted: String
  amountRaw: numeric
  db_write_timestamp: timestamp
  id: String
  market_id: String
  sender: String
  timestamp: numeric
  token_id: String
  transactionHash: String
  treasury_id: String
}

"""
order by sum() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_sum_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_var_pop_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_var_samp_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "FeeSplitterReceipt"
"""
input FeeSplitterReceipt_variance_order_by {
  amountRaw: order_by
  timestamp: order_by
}

"""
columns and relationships of "FloorElevation"
"""
type FloorElevation {
  db_write_timestamp: timestamp
  deployedAmountFormatted: String!
  deployedAmountRaw: numeric!
  id: String!
  market_id: String!
  newFloorPriceFormatted: String!
  newFloorPriceRaw: numeric!
  oldFloorPriceFormatted: String!
  oldFloorPriceRaw: numeric!
  timestamp: numeric!
  transactionHash: String!
}

"""
order by aggregate values of table "FloorElevation"
"""
input FloorElevation_aggregate_order_by {
  avg: FloorElevation_avg_order_by
  count: order_by
  max: FloorElevation_max_order_by
  min: FloorElevation_min_order_by
  stddev: FloorElevation_stddev_order_by
  stddev_pop: FloorElevation_stddev_pop_order_by
  stddev_samp: FloorElevation_stddev_samp_order_by
  sum: FloorElevation_sum_order_by
  var_pop: FloorElevation_var_pop_order_by
  var_samp: FloorElevation_var_samp_order_by
  variance: FloorElevation_variance_order_by
}

"""
order by avg() on columns of table "FloorElevation"
"""
input FloorElevation_avg_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "FloorElevation". All fields are combined with a logical 'AND'.
"""
input FloorElevation_bool_exp {
  _and: [FloorElevation_bool_exp!]
  _not: FloorElevation_bool_exp
  _or: [FloorElevation_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  deployedAmountFormatted: String_comparison_exp
  deployedAmountRaw: numeric_comparison_exp
  id: String_comparison_exp
  market_id: String_comparison_exp
  newFloorPriceFormatted: String_comparison_exp
  newFloorPriceRaw: numeric_comparison_exp
  oldFloorPriceFormatted: String_comparison_exp
  oldFloorPriceRaw: numeric_comparison_exp
  timestamp: numeric_comparison_exp
  transactionHash: String_comparison_exp
}

"""
order by max() on columns of table "FloorElevation"
"""
input FloorElevation_max_order_by {
  db_write_timestamp: order_by
  deployedAmountFormatted: order_by
  deployedAmountRaw: order_by
  id: order_by
  market_id: order_by
  newFloorPriceFormatted: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceFormatted: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
  transactionHash: order_by
}

"""
order by min() on columns of table "FloorElevation"
"""
input FloorElevation_min_order_by {
  db_write_timestamp: order_by
  deployedAmountFormatted: order_by
  deployedAmountRaw: order_by
  id: order_by
  market_id: order_by
  newFloorPriceFormatted: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceFormatted: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
  transactionHash: order_by
}

"""Ordering options when selecting data from "FloorElevation"."""
input FloorElevation_order_by {
  db_write_timestamp: order_by
  deployedAmountFormatted: order_by
  deployedAmountRaw: order_by
  id: order_by
  market_id: order_by
  newFloorPriceFormatted: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceFormatted: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
  transactionHash: order_by
}

"""
select columns of table "FloorElevation"
"""
enum FloorElevation_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  deployedAmountFormatted

  """column name"""
  deployedAmountRaw

  """column name"""
  id

  """column name"""
  market_id

  """column name"""
  newFloorPriceFormatted

  """column name"""
  newFloorPriceRaw

  """column name"""
  oldFloorPriceFormatted

  """column name"""
  oldFloorPriceRaw

  """column name"""
  timestamp

  """column name"""
  transactionHash
}

"""
order by stddev() on columns of table "FloorElevation"
"""
input FloorElevation_stddev_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "FloorElevation"
"""
input FloorElevation_stddev_pop_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "FloorElevation"
"""
input FloorElevation_stddev_samp_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "FloorElevation"
"""
input FloorElevation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: FloorElevation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input FloorElevation_stream_cursor_value_input {
  db_write_timestamp: timestamp
  deployedAmountFormatted: String
  deployedAmountRaw: numeric
  id: String
  market_id: String
  newFloorPriceFormatted: String
  newFloorPriceRaw: numeric
  oldFloorPriceFormatted: String
  oldFloorPriceRaw: numeric
  timestamp: numeric
  transactionHash: String
}

"""
order by sum() on columns of table "FloorElevation"
"""
input FloorElevation_sum_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "FloorElevation"
"""
input FloorElevation_var_pop_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "FloorElevation"
"""
input FloorElevation_var_samp_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "FloorElevation"
"""
input FloorElevation_variance_order_by {
  deployedAmountRaw: order_by
  newFloorPriceRaw: order_by
  oldFloorPriceRaw: order_by
  timestamp: order_by
}

"""
columns and relationships of "GlobalRegistry"
"""
type GlobalRegistry {
  createdAt: numeric!
  db_write_timestamp: timestamp
  floorFactoryAddress: String!
  id: String!
  lastUpdatedAt: numeric!
  moduleFactoryAddress: String!
}

"""
Boolean expression to filter rows from the table "GlobalRegistry". All fields are combined with a logical 'AND'.
"""
input GlobalRegistry_bool_exp {
  _and: [GlobalRegistry_bool_exp!]
  _not: GlobalRegistry_bool_exp
  _or: [GlobalRegistry_bool_exp!]
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  floorFactoryAddress: String_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  moduleFactoryAddress: String_comparison_exp
}

"""Ordering options when selecting data from "GlobalRegistry"."""
input GlobalRegistry_order_by {
  createdAt: order_by
  db_write_timestamp: order_by
  floorFactoryAddress: order_by
  id: order_by
  lastUpdatedAt: order_by
  moduleFactoryAddress: order_by
}

"""
select columns of table "GlobalRegistry"
"""
enum GlobalRegistry_select_column {
  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  floorFactoryAddress

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  moduleFactoryAddress
}

"""
Streaming cursor of the table "GlobalRegistry"
"""
input GlobalRegistry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: GlobalRegistry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input GlobalRegistry_stream_cursor_value_input {
  createdAt: numeric
  db_write_timestamp: timestamp
  floorFactoryAddress: String
  id: String
  lastUpdatedAt: numeric
  moduleFactoryAddress: String
}

"""
columns and relationships of "GlobalStats"
"""
type GlobalStats {
  activeMarkets: numeric!
  db_write_timestamp: timestamp
  id: String!
  lastUpdatedAt: numeric!
  totalLockedCollateralFormatted: String!
  totalLockedCollateralRaw: numeric!
  totalMarkets: numeric!
  totalOutstandingDebtFormatted: String!
  totalOutstandingDebtRaw: numeric!
  totalVolumeFormatted: String!
  totalVolumeRaw: numeric!
}

"""
Boolean expression to filter rows from the table "GlobalStats". All fields are combined with a logical 'AND'.
"""
input GlobalStats_bool_exp {
  _and: [GlobalStats_bool_exp!]
  _not: GlobalStats_bool_exp
  _or: [GlobalStats_bool_exp!]
  activeMarkets: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  totalLockedCollateralFormatted: String_comparison_exp
  totalLockedCollateralRaw: numeric_comparison_exp
  totalMarkets: numeric_comparison_exp
  totalOutstandingDebtFormatted: String_comparison_exp
  totalOutstandingDebtRaw: numeric_comparison_exp
  totalVolumeFormatted: String_comparison_exp
  totalVolumeRaw: numeric_comparison_exp
}

"""Ordering options when selecting data from "GlobalStats"."""
input GlobalStats_order_by {
  activeMarkets: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  totalLockedCollateralFormatted: order_by
  totalLockedCollateralRaw: order_by
  totalMarkets: order_by
  totalOutstandingDebtFormatted: order_by
  totalOutstandingDebtRaw: order_by
  totalVolumeFormatted: order_by
  totalVolumeRaw: order_by
}

"""
select columns of table "GlobalStats"
"""
enum GlobalStats_select_column {
  """column name"""
  activeMarkets

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  totalLockedCollateralFormatted

  """column name"""
  totalLockedCollateralRaw

  """column name"""
  totalMarkets

  """column name"""
  totalOutstandingDebtFormatted

  """column name"""
  totalOutstandingDebtRaw

  """column name"""
  totalVolumeFormatted

  """column name"""
  totalVolumeRaw
}

"""
Streaming cursor of the table "GlobalStats"
"""
input GlobalStats_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: GlobalStats_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input GlobalStats_stream_cursor_value_input {
  activeMarkets: numeric
  db_write_timestamp: timestamp
  id: String
  lastUpdatedAt: numeric
  totalLockedCollateralFormatted: String
  totalLockedCollateralRaw: numeric
  totalMarkets: numeric
  totalOutstandingDebtFormatted: String
  totalOutstandingDebtRaw: numeric
  totalVolumeFormatted: String
  totalVolumeRaw: numeric
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [Int!]

  """does the array contain the given value"""
  _contains: [Int!]
  _eq: [Int!]
  _gt: [Int!]
  _gte: [Int!]
  _in: [[Int!]!]
  _is_null: Boolean
  _lt: [Int!]
  _lte: [Int!]
  _neq: [Int!]
  _nin: [[Int!]!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "Loan"
"""
type Loan {
  borrowAmountFormatted: String!
  borrowAmountRaw: numeric!
  borrower_id: String!
  closedAt: numeric
  db_write_timestamp: timestamp
  facility_id: String!
  floorPriceAtBorrowFormatted: String!
  floorPriceAtBorrowRaw: numeric!
  id: String!
  lastUpdatedAt: numeric!
  lockedCollateralFormatted: String!
  lockedCollateralRaw: numeric!
  market_id: String!
  openedAt: numeric!
  originationFeeFormatted: String!
  originationFeeRaw: numeric!
  remainingDebtFormatted: String!
  remainingDebtRaw: numeric!
  status: loanstatus!

  """An array relationship"""
  statusHistory(
    """distinct select on columns"""
    distinct_on: [LoanStatusHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LoanStatusHistory_order_by!]

    """filter the rows returned"""
    where: LoanStatusHistory_bool_exp
  ): [LoanStatusHistory!]!
  transactionHash: String!
}

"""
columns and relationships of "LoanStatusHistory"
"""
type LoanStatusHistory {
  db_write_timestamp: timestamp
  id: String!
  loan_id: String!
  lockedCollateralFormatted: String!
  lockedCollateralRaw: numeric!
  remainingDebtFormatted: String!
  remainingDebtRaw: numeric!
  status: loanstatus!
  timestamp: numeric!
  transactionHash: String!
}

"""
order by aggregate values of table "LoanStatusHistory"
"""
input LoanStatusHistory_aggregate_order_by {
  avg: LoanStatusHistory_avg_order_by
  count: order_by
  max: LoanStatusHistory_max_order_by
  min: LoanStatusHistory_min_order_by
  stddev: LoanStatusHistory_stddev_order_by
  stddev_pop: LoanStatusHistory_stddev_pop_order_by
  stddev_samp: LoanStatusHistory_stddev_samp_order_by
  sum: LoanStatusHistory_sum_order_by
  var_pop: LoanStatusHistory_var_pop_order_by
  var_samp: LoanStatusHistory_var_samp_order_by
  variance: LoanStatusHistory_variance_order_by
}

"""
order by avg() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_avg_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "LoanStatusHistory". All fields are combined with a logical 'AND'.
"""
input LoanStatusHistory_bool_exp {
  _and: [LoanStatusHistory_bool_exp!]
  _not: LoanStatusHistory_bool_exp
  _or: [LoanStatusHistory_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  loan_id: String_comparison_exp
  lockedCollateralFormatted: String_comparison_exp
  lockedCollateralRaw: numeric_comparison_exp
  remainingDebtFormatted: String_comparison_exp
  remainingDebtRaw: numeric_comparison_exp
  status: loanstatus_comparison_exp
  timestamp: numeric_comparison_exp
  transactionHash: String_comparison_exp
}

"""
order by max() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_max_order_by {
  db_write_timestamp: order_by
  id: order_by
  loan_id: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  remainingDebtFormatted: order_by
  remainingDebtRaw: order_by
  status: order_by
  timestamp: order_by
  transactionHash: order_by
}

"""
order by min() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_min_order_by {
  db_write_timestamp: order_by
  id: order_by
  loan_id: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  remainingDebtFormatted: order_by
  remainingDebtRaw: order_by
  status: order_by
  timestamp: order_by
  transactionHash: order_by
}

"""Ordering options when selecting data from "LoanStatusHistory"."""
input LoanStatusHistory_order_by {
  db_write_timestamp: order_by
  id: order_by
  loan_id: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  remainingDebtFormatted: order_by
  remainingDebtRaw: order_by
  status: order_by
  timestamp: order_by
  transactionHash: order_by
}

"""
select columns of table "LoanStatusHistory"
"""
enum LoanStatusHistory_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  loan_id

  """column name"""
  lockedCollateralFormatted

  """column name"""
  lockedCollateralRaw

  """column name"""
  remainingDebtFormatted

  """column name"""
  remainingDebtRaw

  """column name"""
  status

  """column name"""
  timestamp

  """column name"""
  transactionHash
}

"""
order by stddev() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_stddev_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_stddev_pop_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_stddev_samp_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "LoanStatusHistory"
"""
input LoanStatusHistory_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: LoanStatusHistory_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input LoanStatusHistory_stream_cursor_value_input {
  db_write_timestamp: timestamp
  id: String
  loan_id: String
  lockedCollateralFormatted: String
  lockedCollateralRaw: numeric
  remainingDebtFormatted: String
  remainingDebtRaw: numeric
  status: loanstatus
  timestamp: numeric
  transactionHash: String
}

"""
order by sum() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_sum_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_var_pop_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_var_samp_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "LoanStatusHistory"
"""
input LoanStatusHistory_variance_order_by {
  lockedCollateralRaw: order_by
  remainingDebtRaw: order_by
  timestamp: order_by
}

"""
order by aggregate values of table "Loan"
"""
input Loan_aggregate_order_by {
  avg: Loan_avg_order_by
  count: order_by
  max: Loan_max_order_by
  min: Loan_min_order_by
  stddev: Loan_stddev_order_by
  stddev_pop: Loan_stddev_pop_order_by
  stddev_samp: Loan_stddev_samp_order_by
  sum: Loan_sum_order_by
  var_pop: Loan_var_pop_order_by
  var_samp: Loan_var_samp_order_by
  variance: Loan_variance_order_by
}

"""
order by avg() on columns of table "Loan"
"""
input Loan_avg_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
Boolean expression to filter rows from the table "Loan". All fields are combined with a logical 'AND'.
"""
input Loan_bool_exp {
  _and: [Loan_bool_exp!]
  _not: Loan_bool_exp
  _or: [Loan_bool_exp!]
  borrowAmountFormatted: String_comparison_exp
  borrowAmountRaw: numeric_comparison_exp
  borrower_id: String_comparison_exp
  closedAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  facility_id: String_comparison_exp
  floorPriceAtBorrowFormatted: String_comparison_exp
  floorPriceAtBorrowRaw: numeric_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  lockedCollateralFormatted: String_comparison_exp
  lockedCollateralRaw: numeric_comparison_exp
  market_id: String_comparison_exp
  openedAt: numeric_comparison_exp
  originationFeeFormatted: String_comparison_exp
  originationFeeRaw: numeric_comparison_exp
  remainingDebtFormatted: String_comparison_exp
  remainingDebtRaw: numeric_comparison_exp
  status: loanstatus_comparison_exp
  statusHistory: LoanStatusHistory_bool_exp
  transactionHash: String_comparison_exp
}

"""
order by max() on columns of table "Loan"
"""
input Loan_max_order_by {
  borrowAmountFormatted: order_by
  borrowAmountRaw: order_by
  borrower_id: order_by
  closedAt: order_by
  db_write_timestamp: order_by
  facility_id: order_by
  floorPriceAtBorrowFormatted: order_by
  floorPriceAtBorrowRaw: order_by
  id: order_by
  lastUpdatedAt: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  market_id: order_by
  openedAt: order_by
  originationFeeFormatted: order_by
  originationFeeRaw: order_by
  remainingDebtFormatted: order_by
  remainingDebtRaw: order_by
  status: order_by
  transactionHash: order_by
}

"""
order by min() on columns of table "Loan"
"""
input Loan_min_order_by {
  borrowAmountFormatted: order_by
  borrowAmountRaw: order_by
  borrower_id: order_by
  closedAt: order_by
  db_write_timestamp: order_by
  facility_id: order_by
  floorPriceAtBorrowFormatted: order_by
  floorPriceAtBorrowRaw: order_by
  id: order_by
  lastUpdatedAt: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  market_id: order_by
  openedAt: order_by
  originationFeeFormatted: order_by
  originationFeeRaw: order_by
  remainingDebtFormatted: order_by
  remainingDebtRaw: order_by
  status: order_by
  transactionHash: order_by
}

"""Ordering options when selecting data from "Loan"."""
input Loan_order_by {
  borrowAmountFormatted: order_by
  borrowAmountRaw: order_by
  borrower_id: order_by
  closedAt: order_by
  db_write_timestamp: order_by
  facility_id: order_by
  floorPriceAtBorrowFormatted: order_by
  floorPriceAtBorrowRaw: order_by
  id: order_by
  lastUpdatedAt: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  market_id: order_by
  openedAt: order_by
  originationFeeFormatted: order_by
  originationFeeRaw: order_by
  remainingDebtFormatted: order_by
  remainingDebtRaw: order_by
  status: order_by
  statusHistory_aggregate: LoanStatusHistory_aggregate_order_by
  transactionHash: order_by
}

"""
select columns of table "Loan"
"""
enum Loan_select_column {
  """column name"""
  borrowAmountFormatted

  """column name"""
  borrowAmountRaw

  """column name"""
  borrower_id

  """column name"""
  closedAt

  """column name"""
  db_write_timestamp

  """column name"""
  facility_id

  """column name"""
  floorPriceAtBorrowFormatted

  """column name"""
  floorPriceAtBorrowRaw

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  lockedCollateralFormatted

  """column name"""
  lockedCollateralRaw

  """column name"""
  market_id

  """column name"""
  openedAt

  """column name"""
  originationFeeFormatted

  """column name"""
  originationFeeRaw

  """column name"""
  remainingDebtFormatted

  """column name"""
  remainingDebtRaw

  """column name"""
  status

  """column name"""
  transactionHash
}

"""
order by stddev() on columns of table "Loan"
"""
input Loan_stddev_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
order by stddev_pop() on columns of table "Loan"
"""
input Loan_stddev_pop_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
order by stddev_samp() on columns of table "Loan"
"""
input Loan_stddev_samp_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
Streaming cursor of the table "Loan"
"""
input Loan_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Loan_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Loan_stream_cursor_value_input {
  borrowAmountFormatted: String
  borrowAmountRaw: numeric
  borrower_id: String
  closedAt: numeric
  db_write_timestamp: timestamp
  facility_id: String
  floorPriceAtBorrowFormatted: String
  floorPriceAtBorrowRaw: numeric
  id: String
  lastUpdatedAt: numeric
  lockedCollateralFormatted: String
  lockedCollateralRaw: numeric
  market_id: String
  openedAt: numeric
  originationFeeFormatted: String
  originationFeeRaw: numeric
  remainingDebtFormatted: String
  remainingDebtRaw: numeric
  status: loanstatus
  transactionHash: String
}

"""
order by sum() on columns of table "Loan"
"""
input Loan_sum_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
order by var_pop() on columns of table "Loan"
"""
input Loan_var_pop_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
order by var_samp() on columns of table "Loan"
"""
input Loan_var_samp_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
order by variance() on columns of table "Loan"
"""
input Loan_variance_order_by {
  borrowAmountRaw: order_by
  closedAt: order_by
  floorPriceAtBorrowRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  openedAt: order_by
  originationFeeRaw: order_by
  remainingDebtRaw: order_by
}

"""
columns and relationships of "Market"
"""
type Market {
  buyFeeBps: numeric!
  createdAt: numeric!
  creator_id: String!
  currentPriceFormatted: String!
  currentPriceRaw: numeric!
  db_write_timestamp: timestamp
  factory_id: String!

  """An array relationship"""
  floorElevations(
    """distinct select on columns"""
    distinct_on: [FloorElevation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FloorElevation_order_by!]

    """filter the rows returned"""
    where: FloorElevation_bool_exp
  ): [FloorElevation!]!
  floorPriceFormatted: String!
  floorPriceRaw: numeric!
  floorSupplyFormatted: String!
  floorSupplyRaw: numeric!
  id: String!
  initialFloorPriceFormatted: String!
  initialFloorPriceRaw: numeric!
  isBuyOpen: Boolean!
  isSellOpen: Boolean!

  """An object relationship"""
  issuanceToken: Token
  issuanceToken_id: String!
  lastElevationTimestamp: numeric!
  lastTradeTimestamp: numeric!
  lastUpdatedAt: numeric!
  marketSupplyFormatted: String!
  marketSupplyRaw: numeric!
  maxLTV: numeric!

  """An object relationship"""
  reserveToken: Token
  reserveToken_id: String!
  sellFeeBps: numeric!
  status: marketstatus!
  totalSupplyFormatted: String!
  totalSupplyRaw: numeric!

  """An array relationship"""
  trades(
    """distinct select on columns"""
    distinct_on: [Trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Trade_order_by!]

    """filter the rows returned"""
    where: Trade_bool_exp
  ): [Trade!]!
  tradingFeeBps: numeric!
}

"""
columns and relationships of "MarketRollingStats"
"""
type MarketRollingStats {
  averagePriceFormatted: String!
  averagePriceRaw: numeric!
  db_write_timestamp: timestamp
  id: String!
  lastUpdatedAt: numeric!
  market_id: String!
  tradeCount: numeric!
  volumeFormatted: String!
  volumeRaw: numeric!
  windowSeconds: Int!
}

"""
Boolean expression to filter rows from the table "MarketRollingStats". All fields are combined with a logical 'AND'.
"""
input MarketRollingStats_bool_exp {
  _and: [MarketRollingStats_bool_exp!]
  _not: MarketRollingStats_bool_exp
  _or: [MarketRollingStats_bool_exp!]
  averagePriceFormatted: String_comparison_exp
  averagePriceRaw: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  market_id: String_comparison_exp
  tradeCount: numeric_comparison_exp
  volumeFormatted: String_comparison_exp
  volumeRaw: numeric_comparison_exp
  windowSeconds: Int_comparison_exp
}

"""Ordering options when selecting data from "MarketRollingStats"."""
input MarketRollingStats_order_by {
  averagePriceFormatted: order_by
  averagePriceRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  market_id: order_by
  tradeCount: order_by
  volumeFormatted: order_by
  volumeRaw: order_by
  windowSeconds: order_by
}

"""
select columns of table "MarketRollingStats"
"""
enum MarketRollingStats_select_column {
  """column name"""
  averagePriceFormatted

  """column name"""
  averagePriceRaw

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  market_id

  """column name"""
  tradeCount

  """column name"""
  volumeFormatted

  """column name"""
  volumeRaw

  """column name"""
  windowSeconds
}

"""
Streaming cursor of the table "MarketRollingStats"
"""
input MarketRollingStats_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: MarketRollingStats_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input MarketRollingStats_stream_cursor_value_input {
  averagePriceFormatted: String
  averagePriceRaw: numeric
  db_write_timestamp: timestamp
  id: String
  lastUpdatedAt: numeric
  market_id: String
  tradeCount: numeric
  volumeFormatted: String
  volumeRaw: numeric
  windowSeconds: Int
}

"""
columns and relationships of "MarketSnapshot"
"""
type MarketSnapshot {
  db_write_timestamp: timestamp
  floorPriceFormatted: String!
  floorPriceRaw: numeric!
  id: String!
  marketSupplyFormatted: String!
  marketSupplyRaw: numeric!
  market_id: String!
  priceFormatted: String!
  priceRaw: numeric!
  timestamp: numeric!
  totalSupplyFormatted: String!
  totalSupplyRaw: numeric!
  trades24h: numeric!
  volume24hFormatted: String!
  volume24hRaw: numeric!
}

"""
Boolean expression to filter rows from the table "MarketSnapshot". All fields are combined with a logical 'AND'.
"""
input MarketSnapshot_bool_exp {
  _and: [MarketSnapshot_bool_exp!]
  _not: MarketSnapshot_bool_exp
  _or: [MarketSnapshot_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  floorPriceFormatted: String_comparison_exp
  floorPriceRaw: numeric_comparison_exp
  id: String_comparison_exp
  marketSupplyFormatted: String_comparison_exp
  marketSupplyRaw: numeric_comparison_exp
  market_id: String_comparison_exp
  priceFormatted: String_comparison_exp
  priceRaw: numeric_comparison_exp
  timestamp: numeric_comparison_exp
  totalSupplyFormatted: String_comparison_exp
  totalSupplyRaw: numeric_comparison_exp
  trades24h: numeric_comparison_exp
  volume24hFormatted: String_comparison_exp
  volume24hRaw: numeric_comparison_exp
}

"""Ordering options when selecting data from "MarketSnapshot"."""
input MarketSnapshot_order_by {
  db_write_timestamp: order_by
  floorPriceFormatted: order_by
  floorPriceRaw: order_by
  id: order_by
  marketSupplyFormatted: order_by
  marketSupplyRaw: order_by
  market_id: order_by
  priceFormatted: order_by
  priceRaw: order_by
  timestamp: order_by
  totalSupplyFormatted: order_by
  totalSupplyRaw: order_by
  trades24h: order_by
  volume24hFormatted: order_by
  volume24hRaw: order_by
}

"""
select columns of table "MarketSnapshot"
"""
enum MarketSnapshot_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  floorPriceFormatted

  """column name"""
  floorPriceRaw

  """column name"""
  id

  """column name"""
  marketSupplyFormatted

  """column name"""
  marketSupplyRaw

  """column name"""
  market_id

  """column name"""
  priceFormatted

  """column name"""
  priceRaw

  """column name"""
  timestamp

  """column name"""
  totalSupplyFormatted

  """column name"""
  totalSupplyRaw

  """column name"""
  trades24h

  """column name"""
  volume24hFormatted

  """column name"""
  volume24hRaw
}

"""
Streaming cursor of the table "MarketSnapshot"
"""
input MarketSnapshot_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: MarketSnapshot_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input MarketSnapshot_stream_cursor_value_input {
  db_write_timestamp: timestamp
  floorPriceFormatted: String
  floorPriceRaw: numeric
  id: String
  marketSupplyFormatted: String
  marketSupplyRaw: numeric
  market_id: String
  priceFormatted: String
  priceRaw: numeric
  timestamp: numeric
  totalSupplyFormatted: String
  totalSupplyRaw: numeric
  trades24h: numeric
  volume24hFormatted: String
  volume24hRaw: numeric
}

"""
order by aggregate values of table "Market"
"""
input Market_aggregate_order_by {
  avg: Market_avg_order_by
  count: order_by
  max: Market_max_order_by
  min: Market_min_order_by
  stddev: Market_stddev_order_by
  stddev_pop: Market_stddev_pop_order_by
  stddev_samp: Market_stddev_samp_order_by
  sum: Market_sum_order_by
  var_pop: Market_var_pop_order_by
  var_samp: Market_var_samp_order_by
  variance: Market_variance_order_by
}

"""
order by avg() on columns of table "Market"
"""
input Market_avg_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
Boolean expression to filter rows from the table "Market". All fields are combined with a logical 'AND'.
"""
input Market_bool_exp {
  _and: [Market_bool_exp!]
  _not: Market_bool_exp
  _or: [Market_bool_exp!]
  buyFeeBps: numeric_comparison_exp
  createdAt: numeric_comparison_exp
  creator_id: String_comparison_exp
  currentPriceFormatted: String_comparison_exp
  currentPriceRaw: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  factory_id: String_comparison_exp
  floorElevations: FloorElevation_bool_exp
  floorPriceFormatted: String_comparison_exp
  floorPriceRaw: numeric_comparison_exp
  floorSupplyFormatted: String_comparison_exp
  floorSupplyRaw: numeric_comparison_exp
  id: String_comparison_exp
  initialFloorPriceFormatted: String_comparison_exp
  initialFloorPriceRaw: numeric_comparison_exp
  isBuyOpen: Boolean_comparison_exp
  isSellOpen: Boolean_comparison_exp
  issuanceToken: Token_bool_exp
  issuanceToken_id: String_comparison_exp
  lastElevationTimestamp: numeric_comparison_exp
  lastTradeTimestamp: numeric_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  marketSupplyFormatted: String_comparison_exp
  marketSupplyRaw: numeric_comparison_exp
  maxLTV: numeric_comparison_exp
  reserveToken: Token_bool_exp
  reserveToken_id: String_comparison_exp
  sellFeeBps: numeric_comparison_exp
  status: marketstatus_comparison_exp
  totalSupplyFormatted: String_comparison_exp
  totalSupplyRaw: numeric_comparison_exp
  trades: Trade_bool_exp
  tradingFeeBps: numeric_comparison_exp
}

"""
order by max() on columns of table "Market"
"""
input Market_max_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  creator_id: order_by
  currentPriceFormatted: order_by
  currentPriceRaw: order_by
  db_write_timestamp: order_by
  factory_id: order_by
  floorPriceFormatted: order_by
  floorPriceRaw: order_by
  floorSupplyFormatted: order_by
  floorSupplyRaw: order_by
  id: order_by
  initialFloorPriceFormatted: order_by
  initialFloorPriceRaw: order_by
  issuanceToken_id: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyFormatted: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  reserveToken_id: order_by
  sellFeeBps: order_by
  status: order_by
  totalSupplyFormatted: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
order by min() on columns of table "Market"
"""
input Market_min_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  creator_id: order_by
  currentPriceFormatted: order_by
  currentPriceRaw: order_by
  db_write_timestamp: order_by
  factory_id: order_by
  floorPriceFormatted: order_by
  floorPriceRaw: order_by
  floorSupplyFormatted: order_by
  floorSupplyRaw: order_by
  id: order_by
  initialFloorPriceFormatted: order_by
  initialFloorPriceRaw: order_by
  issuanceToken_id: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyFormatted: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  reserveToken_id: order_by
  sellFeeBps: order_by
  status: order_by
  totalSupplyFormatted: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""Ordering options when selecting data from "Market"."""
input Market_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  creator_id: order_by
  currentPriceFormatted: order_by
  currentPriceRaw: order_by
  db_write_timestamp: order_by
  factory_id: order_by
  floorElevations_aggregate: FloorElevation_aggregate_order_by
  floorPriceFormatted: order_by
  floorPriceRaw: order_by
  floorSupplyFormatted: order_by
  floorSupplyRaw: order_by
  id: order_by
  initialFloorPriceFormatted: order_by
  initialFloorPriceRaw: order_by
  isBuyOpen: order_by
  isSellOpen: order_by
  issuanceToken: Token_order_by
  issuanceToken_id: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyFormatted: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  reserveToken: Token_order_by
  reserveToken_id: order_by
  sellFeeBps: order_by
  status: order_by
  totalSupplyFormatted: order_by
  totalSupplyRaw: order_by
  trades_aggregate: Trade_aggregate_order_by
  tradingFeeBps: order_by
}

"""
select columns of table "Market"
"""
enum Market_select_column {
  """column name"""
  buyFeeBps

  """column name"""
  createdAt

  """column name"""
  creator_id

  """column name"""
  currentPriceFormatted

  """column name"""
  currentPriceRaw

  """column name"""
  db_write_timestamp

  """column name"""
  factory_id

  """column name"""
  floorPriceFormatted

  """column name"""
  floorPriceRaw

  """column name"""
  floorSupplyFormatted

  """column name"""
  floorSupplyRaw

  """column name"""
  id

  """column name"""
  initialFloorPriceFormatted

  """column name"""
  initialFloorPriceRaw

  """column name"""
  isBuyOpen

  """column name"""
  isSellOpen

  """column name"""
  issuanceToken_id

  """column name"""
  lastElevationTimestamp

  """column name"""
  lastTradeTimestamp

  """column name"""
  lastUpdatedAt

  """column name"""
  marketSupplyFormatted

  """column name"""
  marketSupplyRaw

  """column name"""
  maxLTV

  """column name"""
  reserveToken_id

  """column name"""
  sellFeeBps

  """column name"""
  status

  """column name"""
  totalSupplyFormatted

  """column name"""
  totalSupplyRaw

  """column name"""
  tradingFeeBps
}

"""
order by stddev() on columns of table "Market"
"""
input Market_stddev_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
order by stddev_pop() on columns of table "Market"
"""
input Market_stddev_pop_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
order by stddev_samp() on columns of table "Market"
"""
input Market_stddev_samp_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
Streaming cursor of the table "Market"
"""
input Market_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Market_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Market_stream_cursor_value_input {
  buyFeeBps: numeric
  createdAt: numeric
  creator_id: String
  currentPriceFormatted: String
  currentPriceRaw: numeric
  db_write_timestamp: timestamp
  factory_id: String
  floorPriceFormatted: String
  floorPriceRaw: numeric
  floorSupplyFormatted: String
  floorSupplyRaw: numeric
  id: String
  initialFloorPriceFormatted: String
  initialFloorPriceRaw: numeric
  isBuyOpen: Boolean
  isSellOpen: Boolean
  issuanceToken_id: String
  lastElevationTimestamp: numeric
  lastTradeTimestamp: numeric
  lastUpdatedAt: numeric
  marketSupplyFormatted: String
  marketSupplyRaw: numeric
  maxLTV: numeric
  reserveToken_id: String
  sellFeeBps: numeric
  status: marketstatus
  totalSupplyFormatted: String
  totalSupplyRaw: numeric
  tradingFeeBps: numeric
}

"""
order by sum() on columns of table "Market"
"""
input Market_sum_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
order by var_pop() on columns of table "Market"
"""
input Market_var_pop_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
order by var_samp() on columns of table "Market"
"""
input Market_var_samp_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
order by variance() on columns of table "Market"
"""
input Market_variance_order_by {
  buyFeeBps: order_by
  createdAt: order_by
  currentPriceRaw: order_by
  floorPriceRaw: order_by
  floorSupplyRaw: order_by
  initialFloorPriceRaw: order_by
  lastElevationTimestamp: order_by
  lastTradeTimestamp: order_by
  lastUpdatedAt: order_by
  marketSupplyRaw: order_by
  maxLTV: order_by
  sellFeeBps: order_by
  totalSupplyRaw: order_by
  tradingFeeBps: order_by
}

"""
columns and relationships of "ModuleAddress"
"""
type ModuleAddress {
  createdAt: numeric!
  db_write_timestamp: timestamp
  id: String!
  lastUpdatedAt: numeric!
  market_id: String!
  moduleType: String!
}

"""
Boolean expression to filter rows from the table "ModuleAddress". All fields are combined with a logical 'AND'.
"""
input ModuleAddress_bool_exp {
  _and: [ModuleAddress_bool_exp!]
  _not: ModuleAddress_bool_exp
  _or: [ModuleAddress_bool_exp!]
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  market_id: String_comparison_exp
  moduleType: String_comparison_exp
}

"""Ordering options when selecting data from "ModuleAddress"."""
input ModuleAddress_order_by {
  createdAt: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  market_id: order_by
  moduleType: order_by
}

"""
select columns of table "ModuleAddress"
"""
enum ModuleAddress_select_column {
  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  market_id

  """column name"""
  moduleType
}

"""
Streaming cursor of the table "ModuleAddress"
"""
input ModuleAddress_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ModuleAddress_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ModuleAddress_stream_cursor_value_input {
  createdAt: numeric
  db_write_timestamp: timestamp
  id: String
  lastUpdatedAt: numeric
  market_id: String
  moduleType: String
}

"""
columns and relationships of "ModuleRegistry"
"""
type ModuleRegistry {
  authorizer: String!
  createdAt: numeric!
  creditFacility: String
  db_write_timestamp: timestamp
  feeTreasury: String!
  floor: String!
  id: String!
  lastUpdatedAt: numeric!
  presale: String
  staking: String
}

"""
Boolean expression to filter rows from the table "ModuleRegistry". All fields are combined with a logical 'AND'.
"""
input ModuleRegistry_bool_exp {
  _and: [ModuleRegistry_bool_exp!]
  _not: ModuleRegistry_bool_exp
  _or: [ModuleRegistry_bool_exp!]
  authorizer: String_comparison_exp
  createdAt: numeric_comparison_exp
  creditFacility: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  feeTreasury: String_comparison_exp
  floor: String_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  presale: String_comparison_exp
  staking: String_comparison_exp
}

"""Ordering options when selecting data from "ModuleRegistry"."""
input ModuleRegistry_order_by {
  authorizer: order_by
  createdAt: order_by
  creditFacility: order_by
  db_write_timestamp: order_by
  feeTreasury: order_by
  floor: order_by
  id: order_by
  lastUpdatedAt: order_by
  presale: order_by
  staking: order_by
}

"""
select columns of table "ModuleRegistry"
"""
enum ModuleRegistry_select_column {
  """column name"""
  authorizer

  """column name"""
  createdAt

  """column name"""
  creditFacility

  """column name"""
  db_write_timestamp

  """column name"""
  feeTreasury

  """column name"""
  floor

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  presale

  """column name"""
  staking
}

"""
Streaming cursor of the table "ModuleRegistry"
"""
input ModuleRegistry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ModuleRegistry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ModuleRegistry_stream_cursor_value_input {
  authorizer: String
  createdAt: numeric
  creditFacility: String
  db_write_timestamp: timestamp
  feeTreasury: String
  floor: String
  id: String
  lastUpdatedAt: numeric
  presale: String
  staking: String
}

"""
columns and relationships of "PreSaleContract"
"""
type PreSaleContract {
  authorizer: String

  """An array relationship"""
  claims(
    """distinct select on columns"""
    distinct_on: [PresaleClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleClaim_order_by!]

    """filter the rows returned"""
    where: PresaleClaim_bool_exp
  ): [PresaleClaim!]!
  commissionBps: [numeric!]
  createdAt: numeric!
  currentState: Int!
  db_write_timestamp: timestamp
  endTime: numeric!
  feeTreasury: String
  globalDepositCapFormatted: String!
  globalDepositCapRaw: numeric!
  id: String!
  lastUpdatedAt: numeric!
  lendingFacility: String
  market_id: String
  maxLeverage: numeric!

  """An array relationship"""
  participations(
    """distinct select on columns"""
    distinct_on: [PresaleParticipation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleParticipation_order_by!]

    """filter the rows returned"""
    where: PresaleParticipation_bool_exp
  ): [PresaleParticipation!]!
  perAddressDepositCapFormatted: String!
  perAddressDepositCapRaw: numeric!
  priceBreakpointOffsets: [Int!]
  priceBreakpointsFlat: [numeric!]

  """An object relationship"""
  purchaseToken: Token
  purchaseToken_id: String!

  """An object relationship"""
  saleToken: Token
  saleToken_id: String!
  startTime: numeric!
  timeSafeguardTs: numeric
  totalParticipants: numeric!
  totalRaisedFormatted: String!
  totalRaisedRaw: numeric!
  whitelistSize: numeric!
  whitelistedAddresses: [String!]
}

"""
Boolean expression to filter rows from the table "PreSaleContract". All fields are combined with a logical 'AND'.
"""
input PreSaleContract_bool_exp {
  _and: [PreSaleContract_bool_exp!]
  _not: PreSaleContract_bool_exp
  _or: [PreSaleContract_bool_exp!]
  authorizer: String_comparison_exp
  claims: PresaleClaim_bool_exp
  commissionBps: numeric_array_comparison_exp
  createdAt: numeric_comparison_exp
  currentState: Int_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  endTime: numeric_comparison_exp
  feeTreasury: String_comparison_exp
  globalDepositCapFormatted: String_comparison_exp
  globalDepositCapRaw: numeric_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  lendingFacility: String_comparison_exp
  market_id: String_comparison_exp
  maxLeverage: numeric_comparison_exp
  participations: PresaleParticipation_bool_exp
  perAddressDepositCapFormatted: String_comparison_exp
  perAddressDepositCapRaw: numeric_comparison_exp
  priceBreakpointOffsets: Int_array_comparison_exp
  priceBreakpointsFlat: numeric_array_comparison_exp
  purchaseToken: Token_bool_exp
  purchaseToken_id: String_comparison_exp
  saleToken: Token_bool_exp
  saleToken_id: String_comparison_exp
  startTime: numeric_comparison_exp
  timeSafeguardTs: numeric_comparison_exp
  totalParticipants: numeric_comparison_exp
  totalRaisedFormatted: String_comparison_exp
  totalRaisedRaw: numeric_comparison_exp
  whitelistSize: numeric_comparison_exp
  whitelistedAddresses: String_array_comparison_exp
}

"""Ordering options when selecting data from "PreSaleContract"."""
input PreSaleContract_order_by {
  authorizer: order_by
  claims_aggregate: PresaleClaim_aggregate_order_by
  commissionBps: order_by
  createdAt: order_by
  currentState: order_by
  db_write_timestamp: order_by
  endTime: order_by
  feeTreasury: order_by
  globalDepositCapFormatted: order_by
  globalDepositCapRaw: order_by
  id: order_by
  lastUpdatedAt: order_by
  lendingFacility: order_by
  market_id: order_by
  maxLeverage: order_by
  participations_aggregate: PresaleParticipation_aggregate_order_by
  perAddressDepositCapFormatted: order_by
  perAddressDepositCapRaw: order_by
  priceBreakpointOffsets: order_by
  priceBreakpointsFlat: order_by
  purchaseToken: Token_order_by
  purchaseToken_id: order_by
  saleToken: Token_order_by
  saleToken_id: order_by
  startTime: order_by
  timeSafeguardTs: order_by
  totalParticipants: order_by
  totalRaisedFormatted: order_by
  totalRaisedRaw: order_by
  whitelistSize: order_by
  whitelistedAddresses: order_by
}

"""
select columns of table "PreSaleContract"
"""
enum PreSaleContract_select_column {
  """column name"""
  authorizer

  """column name"""
  commissionBps

  """column name"""
  createdAt

  """column name"""
  currentState

  """column name"""
  db_write_timestamp

  """column name"""
  endTime

  """column name"""
  feeTreasury

  """column name"""
  globalDepositCapFormatted

  """column name"""
  globalDepositCapRaw

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  lendingFacility

  """column name"""
  market_id

  """column name"""
  maxLeverage

  """column name"""
  perAddressDepositCapFormatted

  """column name"""
  perAddressDepositCapRaw

  """column name"""
  priceBreakpointOffsets

  """column name"""
  priceBreakpointsFlat

  """column name"""
  purchaseToken_id

  """column name"""
  saleToken_id

  """column name"""
  startTime

  """column name"""
  timeSafeguardTs

  """column name"""
  totalParticipants

  """column name"""
  totalRaisedFormatted

  """column name"""
  totalRaisedRaw

  """column name"""
  whitelistSize

  """column name"""
  whitelistedAddresses
}

"""
Streaming cursor of the table "PreSaleContract"
"""
input PreSaleContract_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: PreSaleContract_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input PreSaleContract_stream_cursor_value_input {
  authorizer: String
  commissionBps: [numeric!]
  createdAt: numeric
  currentState: Int
  db_write_timestamp: timestamp
  endTime: numeric
  feeTreasury: String
  globalDepositCapFormatted: String
  globalDepositCapRaw: numeric
  id: String
  lastUpdatedAt: numeric
  lendingFacility: String
  market_id: String
  maxLeverage: numeric
  perAddressDepositCapFormatted: String
  perAddressDepositCapRaw: numeric
  priceBreakpointOffsets: [Int!]
  priceBreakpointsFlat: [numeric!]
  purchaseToken_id: String
  saleToken_id: String
  startTime: numeric
  timeSafeguardTs: numeric
  totalParticipants: numeric
  totalRaisedFormatted: String
  totalRaisedRaw: numeric
  whitelistSize: numeric
  whitelistedAddresses: [String!]
}

"""
columns and relationships of "PresaleClaim"
"""
type PresaleClaim {
  amountFormatted: String!
  amountRaw: numeric!
  claimType: presaleclaimtype!
  db_write_timestamp: timestamp
  id: String!
  loanId: numeric
  positionId: numeric
  presale_id: String!
  timestamp: numeric!
  trancheIndex: numeric
  transactionHash: String!
}

"""
order by aggregate values of table "PresaleClaim"
"""
input PresaleClaim_aggregate_order_by {
  avg: PresaleClaim_avg_order_by
  count: order_by
  max: PresaleClaim_max_order_by
  min: PresaleClaim_min_order_by
  stddev: PresaleClaim_stddev_order_by
  stddev_pop: PresaleClaim_stddev_pop_order_by
  stddev_samp: PresaleClaim_stddev_samp_order_by
  sum: PresaleClaim_sum_order_by
  var_pop: PresaleClaim_var_pop_order_by
  var_samp: PresaleClaim_var_samp_order_by
  variance: PresaleClaim_variance_order_by
}

"""
order by avg() on columns of table "PresaleClaim"
"""
input PresaleClaim_avg_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
Boolean expression to filter rows from the table "PresaleClaim". All fields are combined with a logical 'AND'.
"""
input PresaleClaim_bool_exp {
  _and: [PresaleClaim_bool_exp!]
  _not: PresaleClaim_bool_exp
  _or: [PresaleClaim_bool_exp!]
  amountFormatted: String_comparison_exp
  amountRaw: numeric_comparison_exp
  claimType: presaleclaimtype_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  loanId: numeric_comparison_exp
  positionId: numeric_comparison_exp
  presale_id: String_comparison_exp
  timestamp: numeric_comparison_exp
  trancheIndex: numeric_comparison_exp
  transactionHash: String_comparison_exp
}

"""
order by max() on columns of table "PresaleClaim"
"""
input PresaleClaim_max_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  claimType: order_by
  db_write_timestamp: order_by
  id: order_by
  loanId: order_by
  positionId: order_by
  presale_id: order_by
  timestamp: order_by
  trancheIndex: order_by
  transactionHash: order_by
}

"""
order by min() on columns of table "PresaleClaim"
"""
input PresaleClaim_min_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  claimType: order_by
  db_write_timestamp: order_by
  id: order_by
  loanId: order_by
  positionId: order_by
  presale_id: order_by
  timestamp: order_by
  trancheIndex: order_by
  transactionHash: order_by
}

"""Ordering options when selecting data from "PresaleClaim"."""
input PresaleClaim_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  claimType: order_by
  db_write_timestamp: order_by
  id: order_by
  loanId: order_by
  positionId: order_by
  presale_id: order_by
  timestamp: order_by
  trancheIndex: order_by
  transactionHash: order_by
}

"""
select columns of table "PresaleClaim"
"""
enum PresaleClaim_select_column {
  """column name"""
  amountFormatted

  """column name"""
  amountRaw

  """column name"""
  claimType

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  loanId

  """column name"""
  positionId

  """column name"""
  presale_id

  """column name"""
  timestamp

  """column name"""
  trancheIndex

  """column name"""
  transactionHash
}

"""
order by stddev() on columns of table "PresaleClaim"
"""
input PresaleClaim_stddev_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
order by stddev_pop() on columns of table "PresaleClaim"
"""
input PresaleClaim_stddev_pop_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
order by stddev_samp() on columns of table "PresaleClaim"
"""
input PresaleClaim_stddev_samp_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
Streaming cursor of the table "PresaleClaim"
"""
input PresaleClaim_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: PresaleClaim_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input PresaleClaim_stream_cursor_value_input {
  amountFormatted: String
  amountRaw: numeric
  claimType: presaleclaimtype
  db_write_timestamp: timestamp
  id: String
  loanId: numeric
  positionId: numeric
  presale_id: String
  timestamp: numeric
  trancheIndex: numeric
  transactionHash: String
}

"""
order by sum() on columns of table "PresaleClaim"
"""
input PresaleClaim_sum_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
order by var_pop() on columns of table "PresaleClaim"
"""
input PresaleClaim_var_pop_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
order by var_samp() on columns of table "PresaleClaim"
"""
input PresaleClaim_var_samp_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
order by variance() on columns of table "PresaleClaim"
"""
input PresaleClaim_variance_order_by {
  amountRaw: order_by
  loanId: order_by
  positionId: order_by
  timestamp: order_by
  trancheIndex: order_by
}

"""
columns and relationships of "PresaleParticipation"
"""
type PresaleParticipation {
  db_write_timestamp: timestamp
  depositAmountFormatted: String!
  depositAmountRaw: numeric!
  id: String!
  leverage: numeric!
  loopCount: numeric
  mintedAmountFormatted: String
  mintedAmountRaw: numeric
  positionId: numeric
  presale_id: String!
  timestamp: numeric!
  transactionHash: String!
  user_id: String!
}

"""
order by aggregate values of table "PresaleParticipation"
"""
input PresaleParticipation_aggregate_order_by {
  avg: PresaleParticipation_avg_order_by
  count: order_by
  max: PresaleParticipation_max_order_by
  min: PresaleParticipation_min_order_by
  stddev: PresaleParticipation_stddev_order_by
  stddev_pop: PresaleParticipation_stddev_pop_order_by
  stddev_samp: PresaleParticipation_stddev_samp_order_by
  sum: PresaleParticipation_sum_order_by
  var_pop: PresaleParticipation_var_pop_order_by
  var_samp: PresaleParticipation_var_samp_order_by
  variance: PresaleParticipation_variance_order_by
}

"""
order by avg() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_avg_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "PresaleParticipation". All fields are combined with a logical 'AND'.
"""
input PresaleParticipation_bool_exp {
  _and: [PresaleParticipation_bool_exp!]
  _not: PresaleParticipation_bool_exp
  _or: [PresaleParticipation_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  depositAmountFormatted: String_comparison_exp
  depositAmountRaw: numeric_comparison_exp
  id: String_comparison_exp
  leverage: numeric_comparison_exp
  loopCount: numeric_comparison_exp
  mintedAmountFormatted: String_comparison_exp
  mintedAmountRaw: numeric_comparison_exp
  positionId: numeric_comparison_exp
  presale_id: String_comparison_exp
  timestamp: numeric_comparison_exp
  transactionHash: String_comparison_exp
  user_id: String_comparison_exp
}

"""
order by max() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_max_order_by {
  db_write_timestamp: order_by
  depositAmountFormatted: order_by
  depositAmountRaw: order_by
  id: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountFormatted: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  presale_id: order_by
  timestamp: order_by
  transactionHash: order_by
  user_id: order_by
}

"""
order by min() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_min_order_by {
  db_write_timestamp: order_by
  depositAmountFormatted: order_by
  depositAmountRaw: order_by
  id: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountFormatted: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  presale_id: order_by
  timestamp: order_by
  transactionHash: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "PresaleParticipation"."""
input PresaleParticipation_order_by {
  db_write_timestamp: order_by
  depositAmountFormatted: order_by
  depositAmountRaw: order_by
  id: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountFormatted: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  presale_id: order_by
  timestamp: order_by
  transactionHash: order_by
  user_id: order_by
}

"""
select columns of table "PresaleParticipation"
"""
enum PresaleParticipation_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  depositAmountFormatted

  """column name"""
  depositAmountRaw

  """column name"""
  id

  """column name"""
  leverage

  """column name"""
  loopCount

  """column name"""
  mintedAmountFormatted

  """column name"""
  mintedAmountRaw

  """column name"""
  positionId

  """column name"""
  presale_id

  """column name"""
  timestamp

  """column name"""
  transactionHash

  """column name"""
  user_id
}

"""
order by stddev() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_stddev_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_stddev_pop_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_stddev_samp_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "PresaleParticipation"
"""
input PresaleParticipation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: PresaleParticipation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input PresaleParticipation_stream_cursor_value_input {
  db_write_timestamp: timestamp
  depositAmountFormatted: String
  depositAmountRaw: numeric
  id: String
  leverage: numeric
  loopCount: numeric
  mintedAmountFormatted: String
  mintedAmountRaw: numeric
  positionId: numeric
  presale_id: String
  timestamp: numeric
  transactionHash: String
  user_id: String
}

"""
order by sum() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_sum_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_var_pop_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_var_samp_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "PresaleParticipation"
"""
input PresaleParticipation_variance_order_by {
  depositAmountRaw: order_by
  leverage: order_by
  loopCount: order_by
  mintedAmountRaw: order_by
  positionId: order_by
  timestamp: order_by
}

"""
columns and relationships of "PriceCandle"
"""
type PriceCandle {
  closeFormatted: String!
  closeRaw: numeric!
  db_write_timestamp: timestamp
  highFormatted: String!
  highRaw: numeric!
  id: String!
  lowFormatted: String!
  lowRaw: numeric!
  market_id: String!
  openFormatted: String!
  openRaw: numeric!
  period: candleperiod!
  timestamp: numeric!
  trades: numeric!
  volumeFormatted: String!
  volumeRaw: numeric!
}

"""
Boolean expression to filter rows from the table "PriceCandle". All fields are combined with a logical 'AND'.
"""
input PriceCandle_bool_exp {
  _and: [PriceCandle_bool_exp!]
  _not: PriceCandle_bool_exp
  _or: [PriceCandle_bool_exp!]
  closeFormatted: String_comparison_exp
  closeRaw: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  highFormatted: String_comparison_exp
  highRaw: numeric_comparison_exp
  id: String_comparison_exp
  lowFormatted: String_comparison_exp
  lowRaw: numeric_comparison_exp
  market_id: String_comparison_exp
  openFormatted: String_comparison_exp
  openRaw: numeric_comparison_exp
  period: candleperiod_comparison_exp
  timestamp: numeric_comparison_exp
  trades: numeric_comparison_exp
  volumeFormatted: String_comparison_exp
  volumeRaw: numeric_comparison_exp
}

"""Ordering options when selecting data from "PriceCandle"."""
input PriceCandle_order_by {
  closeFormatted: order_by
  closeRaw: order_by
  db_write_timestamp: order_by
  highFormatted: order_by
  highRaw: order_by
  id: order_by
  lowFormatted: order_by
  lowRaw: order_by
  market_id: order_by
  openFormatted: order_by
  openRaw: order_by
  period: order_by
  timestamp: order_by
  trades: order_by
  volumeFormatted: order_by
  volumeRaw: order_by
}

"""
select columns of table "PriceCandle"
"""
enum PriceCandle_select_column {
  """column name"""
  closeFormatted

  """column name"""
  closeRaw

  """column name"""
  db_write_timestamp

  """column name"""
  highFormatted

  """column name"""
  highRaw

  """column name"""
  id

  """column name"""
  lowFormatted

  """column name"""
  lowRaw

  """column name"""
  market_id

  """column name"""
  openFormatted

  """column name"""
  openRaw

  """column name"""
  period

  """column name"""
  timestamp

  """column name"""
  trades

  """column name"""
  volumeFormatted

  """column name"""
  volumeRaw
}

"""
Streaming cursor of the table "PriceCandle"
"""
input PriceCandle_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: PriceCandle_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input PriceCandle_stream_cursor_value_input {
  closeFormatted: String
  closeRaw: numeric
  db_write_timestamp: timestamp
  highFormatted: String
  highRaw: numeric
  id: String
  lowFormatted: String
  lowRaw: numeric
  market_id: String
  openFormatted: String
  openRaw: numeric
  period: candleperiod
  timestamp: numeric
  trades: numeric
  volumeFormatted: String
  volumeRaw: numeric
}

"""
columns and relationships of "Role"
"""
type Role {
  adminRole: String
  adminRoleName: String
  authorizer_id: String!
  createdAt: numeric!
  db_write_timestamp: timestamp
  id: String!
  isAdminBurned: Boolean!
  lastUpdatedAt: numeric!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [RoleMember_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [RoleMember_order_by!]

    """filter the rows returned"""
    where: RoleMember_bool_exp
  ): [RoleMember!]!
  name: String

  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [RolePermission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [RolePermission_order_by!]

    """filter the rows returned"""
    where: RolePermission_bool_exp
  ): [RolePermission!]!
  roleId: String!
}

"""
columns and relationships of "RoleMember"
"""
type RoleMember {
  db_write_timestamp: timestamp
  grantedAt: numeric!
  grantedBy: String!
  id: String!
  member: String!
  role_id: String!
  transactionHash: String!
}

"""
order by aggregate values of table "RoleMember"
"""
input RoleMember_aggregate_order_by {
  avg: RoleMember_avg_order_by
  count: order_by
  max: RoleMember_max_order_by
  min: RoleMember_min_order_by
  stddev: RoleMember_stddev_order_by
  stddev_pop: RoleMember_stddev_pop_order_by
  stddev_samp: RoleMember_stddev_samp_order_by
  sum: RoleMember_sum_order_by
  var_pop: RoleMember_var_pop_order_by
  var_samp: RoleMember_var_samp_order_by
  variance: RoleMember_variance_order_by
}

"""
order by avg() on columns of table "RoleMember"
"""
input RoleMember_avg_order_by {
  grantedAt: order_by
}

"""
Boolean expression to filter rows from the table "RoleMember". All fields are combined with a logical 'AND'.
"""
input RoleMember_bool_exp {
  _and: [RoleMember_bool_exp!]
  _not: RoleMember_bool_exp
  _or: [RoleMember_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  grantedAt: numeric_comparison_exp
  grantedBy: String_comparison_exp
  id: String_comparison_exp
  member: String_comparison_exp
  role_id: String_comparison_exp
  transactionHash: String_comparison_exp
}

"""
order by max() on columns of table "RoleMember"
"""
input RoleMember_max_order_by {
  db_write_timestamp: order_by
  grantedAt: order_by
  grantedBy: order_by
  id: order_by
  member: order_by
  role_id: order_by
  transactionHash: order_by
}

"""
order by min() on columns of table "RoleMember"
"""
input RoleMember_min_order_by {
  db_write_timestamp: order_by
  grantedAt: order_by
  grantedBy: order_by
  id: order_by
  member: order_by
  role_id: order_by
  transactionHash: order_by
}

"""Ordering options when selecting data from "RoleMember"."""
input RoleMember_order_by {
  db_write_timestamp: order_by
  grantedAt: order_by
  grantedBy: order_by
  id: order_by
  member: order_by
  role_id: order_by
  transactionHash: order_by
}

"""
select columns of table "RoleMember"
"""
enum RoleMember_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  grantedAt

  """column name"""
  grantedBy

  """column name"""
  id

  """column name"""
  member

  """column name"""
  role_id

  """column name"""
  transactionHash
}

"""
order by stddev() on columns of table "RoleMember"
"""
input RoleMember_stddev_order_by {
  grantedAt: order_by
}

"""
order by stddev_pop() on columns of table "RoleMember"
"""
input RoleMember_stddev_pop_order_by {
  grantedAt: order_by
}

"""
order by stddev_samp() on columns of table "RoleMember"
"""
input RoleMember_stddev_samp_order_by {
  grantedAt: order_by
}

"""
Streaming cursor of the table "RoleMember"
"""
input RoleMember_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: RoleMember_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input RoleMember_stream_cursor_value_input {
  db_write_timestamp: timestamp
  grantedAt: numeric
  grantedBy: String
  id: String
  member: String
  role_id: String
  transactionHash: String
}

"""
order by sum() on columns of table "RoleMember"
"""
input RoleMember_sum_order_by {
  grantedAt: order_by
}

"""
order by var_pop() on columns of table "RoleMember"
"""
input RoleMember_var_pop_order_by {
  grantedAt: order_by
}

"""
order by var_samp() on columns of table "RoleMember"
"""
input RoleMember_var_samp_order_by {
  grantedAt: order_by
}

"""
order by variance() on columns of table "RoleMember"
"""
input RoleMember_variance_order_by {
  grantedAt: order_by
}

"""
columns and relationships of "RolePermission"
"""
type RolePermission {
  addedAt: numeric!
  db_write_timestamp: timestamp
  id: String!
  role_id: String!
  selector: String!
  selectorName: String!
  target: String!
  transactionHash: String!
}

"""
order by aggregate values of table "RolePermission"
"""
input RolePermission_aggregate_order_by {
  avg: RolePermission_avg_order_by
  count: order_by
  max: RolePermission_max_order_by
  min: RolePermission_min_order_by
  stddev: RolePermission_stddev_order_by
  stddev_pop: RolePermission_stddev_pop_order_by
  stddev_samp: RolePermission_stddev_samp_order_by
  sum: RolePermission_sum_order_by
  var_pop: RolePermission_var_pop_order_by
  var_samp: RolePermission_var_samp_order_by
  variance: RolePermission_variance_order_by
}

"""
order by avg() on columns of table "RolePermission"
"""
input RolePermission_avg_order_by {
  addedAt: order_by
}

"""
Boolean expression to filter rows from the table "RolePermission". All fields are combined with a logical 'AND'.
"""
input RolePermission_bool_exp {
  _and: [RolePermission_bool_exp!]
  _not: RolePermission_bool_exp
  _or: [RolePermission_bool_exp!]
  addedAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  role_id: String_comparison_exp
  selector: String_comparison_exp
  selectorName: String_comparison_exp
  target: String_comparison_exp
  transactionHash: String_comparison_exp
}

"""
order by max() on columns of table "RolePermission"
"""
input RolePermission_max_order_by {
  addedAt: order_by
  db_write_timestamp: order_by
  id: order_by
  role_id: order_by
  selector: order_by
  selectorName: order_by
  target: order_by
  transactionHash: order_by
}

"""
order by min() on columns of table "RolePermission"
"""
input RolePermission_min_order_by {
  addedAt: order_by
  db_write_timestamp: order_by
  id: order_by
  role_id: order_by
  selector: order_by
  selectorName: order_by
  target: order_by
  transactionHash: order_by
}

"""Ordering options when selecting data from "RolePermission"."""
input RolePermission_order_by {
  addedAt: order_by
  db_write_timestamp: order_by
  id: order_by
  role_id: order_by
  selector: order_by
  selectorName: order_by
  target: order_by
  transactionHash: order_by
}

"""
select columns of table "RolePermission"
"""
enum RolePermission_select_column {
  """column name"""
  addedAt

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  selector

  """column name"""
  selectorName

  """column name"""
  target

  """column name"""
  transactionHash
}

"""
order by stddev() on columns of table "RolePermission"
"""
input RolePermission_stddev_order_by {
  addedAt: order_by
}

"""
order by stddev_pop() on columns of table "RolePermission"
"""
input RolePermission_stddev_pop_order_by {
  addedAt: order_by
}

"""
order by stddev_samp() on columns of table "RolePermission"
"""
input RolePermission_stddev_samp_order_by {
  addedAt: order_by
}

"""
Streaming cursor of the table "RolePermission"
"""
input RolePermission_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: RolePermission_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input RolePermission_stream_cursor_value_input {
  addedAt: numeric
  db_write_timestamp: timestamp
  id: String
  role_id: String
  selector: String
  selectorName: String
  target: String
  transactionHash: String
}

"""
order by sum() on columns of table "RolePermission"
"""
input RolePermission_sum_order_by {
  addedAt: order_by
}

"""
order by var_pop() on columns of table "RolePermission"
"""
input RolePermission_var_pop_order_by {
  addedAt: order_by
}

"""
order by var_samp() on columns of table "RolePermission"
"""
input RolePermission_var_samp_order_by {
  addedAt: order_by
}

"""
order by variance() on columns of table "RolePermission"
"""
input RolePermission_variance_order_by {
  addedAt: order_by
}

"""
order by aggregate values of table "Role"
"""
input Role_aggregate_order_by {
  avg: Role_avg_order_by
  count: order_by
  max: Role_max_order_by
  min: Role_min_order_by
  stddev: Role_stddev_order_by
  stddev_pop: Role_stddev_pop_order_by
  stddev_samp: Role_stddev_samp_order_by
  sum: Role_sum_order_by
  var_pop: Role_var_pop_order_by
  var_samp: Role_var_samp_order_by
  variance: Role_variance_order_by
}

"""
order by avg() on columns of table "Role"
"""
input Role_avg_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
Boolean expression to filter rows from the table "Role". All fields are combined with a logical 'AND'.
"""
input Role_bool_exp {
  _and: [Role_bool_exp!]
  _not: Role_bool_exp
  _or: [Role_bool_exp!]
  adminRole: String_comparison_exp
  adminRoleName: String_comparison_exp
  authorizer_id: String_comparison_exp
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  isAdminBurned: Boolean_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  members: RoleMember_bool_exp
  name: String_comparison_exp
  permissions: RolePermission_bool_exp
  roleId: String_comparison_exp
}

"""
order by max() on columns of table "Role"
"""
input Role_max_order_by {
  adminRole: order_by
  adminRoleName: order_by
  authorizer_id: order_by
  createdAt: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  roleId: order_by
}

"""
order by min() on columns of table "Role"
"""
input Role_min_order_by {
  adminRole: order_by
  adminRoleName: order_by
  authorizer_id: order_by
  createdAt: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  name: order_by
  roleId: order_by
}

"""Ordering options when selecting data from "Role"."""
input Role_order_by {
  adminRole: order_by
  adminRoleName: order_by
  authorizer_id: order_by
  createdAt: order_by
  db_write_timestamp: order_by
  id: order_by
  isAdminBurned: order_by
  lastUpdatedAt: order_by
  members_aggregate: RoleMember_aggregate_order_by
  name: order_by
  permissions_aggregate: RolePermission_aggregate_order_by
  roleId: order_by
}

"""
select columns of table "Role"
"""
enum Role_select_column {
  """column name"""
  adminRole

  """column name"""
  adminRoleName

  """column name"""
  authorizer_id

  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  isAdminBurned

  """column name"""
  lastUpdatedAt

  """column name"""
  name

  """column name"""
  roleId
}

"""
order by stddev() on columns of table "Role"
"""
input Role_stddev_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
order by stddev_pop() on columns of table "Role"
"""
input Role_stddev_pop_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
order by stddev_samp() on columns of table "Role"
"""
input Role_stddev_samp_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
Streaming cursor of the table "Role"
"""
input Role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Role_stream_cursor_value_input {
  adminRole: String
  adminRoleName: String
  authorizer_id: String
  createdAt: numeric
  db_write_timestamp: timestamp
  id: String
  isAdminBurned: Boolean
  lastUpdatedAt: numeric
  name: String
  roleId: String
}

"""
order by sum() on columns of table "Role"
"""
input Role_sum_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
order by var_pop() on columns of table "Role"
"""
input Role_var_pop_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
order by var_samp() on columns of table "Role"
"""
input Role_var_samp_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
order by variance() on columns of table "Role"
"""
input Role_variance_order_by {
  createdAt: order_by
  lastUpdatedAt: order_by
}

"""
columns and relationships of "Stake"
"""
type Stake {
  amountFormatted: String!
  amountRaw: numeric!
  contract_id: String!
  db_write_timestamp: timestamp
  id: String!
  lockDuration: numeric!
  status: stakestatus!
  timestamp: numeric!
  transactionHash: String!
  user_id: String!
}

"""
order by aggregate values of table "Stake"
"""
input Stake_aggregate_order_by {
  avg: Stake_avg_order_by
  count: order_by
  max: Stake_max_order_by
  min: Stake_min_order_by
  stddev: Stake_stddev_order_by
  stddev_pop: Stake_stddev_pop_order_by
  stddev_samp: Stake_stddev_samp_order_by
  sum: Stake_sum_order_by
  var_pop: Stake_var_pop_order_by
  var_samp: Stake_var_samp_order_by
  variance: Stake_variance_order_by
}

"""
order by avg() on columns of table "Stake"
"""
input Stake_avg_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
Boolean expression to filter rows from the table "Stake". All fields are combined with a logical 'AND'.
"""
input Stake_bool_exp {
  _and: [Stake_bool_exp!]
  _not: Stake_bool_exp
  _or: [Stake_bool_exp!]
  amountFormatted: String_comparison_exp
  amountRaw: numeric_comparison_exp
  contract_id: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  lockDuration: numeric_comparison_exp
  status: stakestatus_comparison_exp
  timestamp: numeric_comparison_exp
  transactionHash: String_comparison_exp
  user_id: String_comparison_exp
}

"""
order by max() on columns of table "Stake"
"""
input Stake_max_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  contract_id: order_by
  db_write_timestamp: order_by
  id: order_by
  lockDuration: order_by
  status: order_by
  timestamp: order_by
  transactionHash: order_by
  user_id: order_by
}

"""
order by min() on columns of table "Stake"
"""
input Stake_min_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  contract_id: order_by
  db_write_timestamp: order_by
  id: order_by
  lockDuration: order_by
  status: order_by
  timestamp: order_by
  transactionHash: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "Stake"."""
input Stake_order_by {
  amountFormatted: order_by
  amountRaw: order_by
  contract_id: order_by
  db_write_timestamp: order_by
  id: order_by
  lockDuration: order_by
  status: order_by
  timestamp: order_by
  transactionHash: order_by
  user_id: order_by
}

"""
select columns of table "Stake"
"""
enum Stake_select_column {
  """column name"""
  amountFormatted

  """column name"""
  amountRaw

  """column name"""
  contract_id

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lockDuration

  """column name"""
  status

  """column name"""
  timestamp

  """column name"""
  transactionHash

  """column name"""
  user_id
}

"""
order by stddev() on columns of table "Stake"
"""
input Stake_stddev_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
order by stddev_pop() on columns of table "Stake"
"""
input Stake_stddev_pop_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
order by stddev_samp() on columns of table "Stake"
"""
input Stake_stddev_samp_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
Streaming cursor of the table "Stake"
"""
input Stake_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Stake_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Stake_stream_cursor_value_input {
  amountFormatted: String
  amountRaw: numeric
  contract_id: String
  db_write_timestamp: timestamp
  id: String
  lockDuration: numeric
  status: stakestatus
  timestamp: numeric
  transactionHash: String
  user_id: String
}

"""
order by sum() on columns of table "Stake"
"""
input Stake_sum_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
order by var_pop() on columns of table "Stake"
"""
input Stake_var_pop_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
order by var_samp() on columns of table "Stake"
"""
input Stake_var_samp_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
order by variance() on columns of table "Stake"
"""
input Stake_variance_order_by {
  amountRaw: order_by
  lockDuration: order_by
  timestamp: order_by
}

"""
columns and relationships of "StakingContract"
"""
type StakingContract {
  createdAt: numeric!
  db_write_timestamp: timestamp
  id: String!
  rewardToken_id: String!

  """An array relationship"""
  stakes(
    """distinct select on columns"""
    distinct_on: [Stake_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Stake_order_by!]

    """filter the rows returned"""
    where: Stake_bool_exp
  ): [Stake!]!
  stakingToken_id: String!
  totalRewardsFormatted: String!
  totalRewardsRaw: numeric!
  totalStakedFormatted: String!
  totalStakedRaw: numeric!
}

"""
Boolean expression to filter rows from the table "StakingContract". All fields are combined with a logical 'AND'.
"""
input StakingContract_bool_exp {
  _and: [StakingContract_bool_exp!]
  _not: StakingContract_bool_exp
  _or: [StakingContract_bool_exp!]
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  rewardToken_id: String_comparison_exp
  stakes: Stake_bool_exp
  stakingToken_id: String_comparison_exp
  totalRewardsFormatted: String_comparison_exp
  totalRewardsRaw: numeric_comparison_exp
  totalStakedFormatted: String_comparison_exp
  totalStakedRaw: numeric_comparison_exp
}

"""Ordering options when selecting data from "StakingContract"."""
input StakingContract_order_by {
  createdAt: order_by
  db_write_timestamp: order_by
  id: order_by
  rewardToken_id: order_by
  stakes_aggregate: Stake_aggregate_order_by
  stakingToken_id: order_by
  totalRewardsFormatted: order_by
  totalRewardsRaw: order_by
  totalStakedFormatted: order_by
  totalStakedRaw: order_by
}

"""
select columns of table "StakingContract"
"""
enum StakingContract_select_column {
  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  rewardToken_id

  """column name"""
  stakingToken_id

  """column name"""
  totalRewardsFormatted

  """column name"""
  totalRewardsRaw

  """column name"""
  totalStakedFormatted

  """column name"""
  totalStakedRaw
}

"""
Streaming cursor of the table "StakingContract"
"""
input StakingContract_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: StakingContract_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input StakingContract_stream_cursor_value_input {
  createdAt: numeric
  db_write_timestamp: timestamp
  id: String
  rewardToken_id: String
  stakingToken_id: String
  totalRewardsFormatted: String
  totalRewardsRaw: numeric
  totalStakedFormatted: String
  totalStakedRaw: numeric
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Token"
"""
type Token {
  db_write_timestamp: timestamp
  decimals: Int!
  id: String!
  maxSupplyFormatted: String!
  maxSupplyRaw: numeric!
  name: String!
  symbol: String!
}

"""
Boolean expression to filter rows from the table "Token". All fields are combined with a logical 'AND'.
"""
input Token_bool_exp {
  _and: [Token_bool_exp!]
  _not: Token_bool_exp
  _or: [Token_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  decimals: Int_comparison_exp
  id: String_comparison_exp
  maxSupplyFormatted: String_comparison_exp
  maxSupplyRaw: numeric_comparison_exp
  name: String_comparison_exp
  symbol: String_comparison_exp
}

"""Ordering options when selecting data from "Token"."""
input Token_order_by {
  db_write_timestamp: order_by
  decimals: order_by
  id: order_by
  maxSupplyFormatted: order_by
  maxSupplyRaw: order_by
  name: order_by
  symbol: order_by
}

"""
select columns of table "Token"
"""
enum Token_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  decimals

  """column name"""
  id

  """column name"""
  maxSupplyFormatted

  """column name"""
  maxSupplyRaw

  """column name"""
  name

  """column name"""
  symbol
}

"""
Streaming cursor of the table "Token"
"""
input Token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Token_stream_cursor_value_input {
  db_write_timestamp: timestamp
  decimals: Int
  id: String
  maxSupplyFormatted: String
  maxSupplyRaw: numeric
  name: String
  symbol: String
}

"""
columns and relationships of "Trade"
"""
type Trade {
  db_write_timestamp: timestamp
  feeFormatted: String!
  feeRaw: numeric!
  id: String!
  market_id: String!
  newPriceFormatted: String!
  newPriceRaw: numeric!
  reserveAmountFormatted: String!
  reserveAmountRaw: numeric!
  timestamp: numeric!
  tokenAmountFormatted: String!
  tokenAmountRaw: numeric!
  tradeType: tradetype!
  transactionHash: String!
  user_id: String!
}

"""
order by aggregate values of table "Trade"
"""
input Trade_aggregate_order_by {
  avg: Trade_avg_order_by
  count: order_by
  max: Trade_max_order_by
  min: Trade_min_order_by
  stddev: Trade_stddev_order_by
  stddev_pop: Trade_stddev_pop_order_by
  stddev_samp: Trade_stddev_samp_order_by
  sum: Trade_sum_order_by
  var_pop: Trade_var_pop_order_by
  var_samp: Trade_var_samp_order_by
  variance: Trade_variance_order_by
}

"""
order by avg() on columns of table "Trade"
"""
input Trade_avg_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
Boolean expression to filter rows from the table "Trade". All fields are combined with a logical 'AND'.
"""
input Trade_bool_exp {
  _and: [Trade_bool_exp!]
  _not: Trade_bool_exp
  _or: [Trade_bool_exp!]
  db_write_timestamp: timestamp_comparison_exp
  feeFormatted: String_comparison_exp
  feeRaw: numeric_comparison_exp
  id: String_comparison_exp
  market_id: String_comparison_exp
  newPriceFormatted: String_comparison_exp
  newPriceRaw: numeric_comparison_exp
  reserveAmountFormatted: String_comparison_exp
  reserveAmountRaw: numeric_comparison_exp
  timestamp: numeric_comparison_exp
  tokenAmountFormatted: String_comparison_exp
  tokenAmountRaw: numeric_comparison_exp
  tradeType: tradetype_comparison_exp
  transactionHash: String_comparison_exp
  user_id: String_comparison_exp
}

"""
order by max() on columns of table "Trade"
"""
input Trade_max_order_by {
  db_write_timestamp: order_by
  feeFormatted: order_by
  feeRaw: order_by
  id: order_by
  market_id: order_by
  newPriceFormatted: order_by
  newPriceRaw: order_by
  reserveAmountFormatted: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountFormatted: order_by
  tokenAmountRaw: order_by
  tradeType: order_by
  transactionHash: order_by
  user_id: order_by
}

"""
order by min() on columns of table "Trade"
"""
input Trade_min_order_by {
  db_write_timestamp: order_by
  feeFormatted: order_by
  feeRaw: order_by
  id: order_by
  market_id: order_by
  newPriceFormatted: order_by
  newPriceRaw: order_by
  reserveAmountFormatted: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountFormatted: order_by
  tokenAmountRaw: order_by
  tradeType: order_by
  transactionHash: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "Trade"."""
input Trade_order_by {
  db_write_timestamp: order_by
  feeFormatted: order_by
  feeRaw: order_by
  id: order_by
  market_id: order_by
  newPriceFormatted: order_by
  newPriceRaw: order_by
  reserveAmountFormatted: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountFormatted: order_by
  tokenAmountRaw: order_by
  tradeType: order_by
  transactionHash: order_by
  user_id: order_by
}

"""
select columns of table "Trade"
"""
enum Trade_select_column {
  """column name"""
  db_write_timestamp

  """column name"""
  feeFormatted

  """column name"""
  feeRaw

  """column name"""
  id

  """column name"""
  market_id

  """column name"""
  newPriceFormatted

  """column name"""
  newPriceRaw

  """column name"""
  reserveAmountFormatted

  """column name"""
  reserveAmountRaw

  """column name"""
  timestamp

  """column name"""
  tokenAmountFormatted

  """column name"""
  tokenAmountRaw

  """column name"""
  tradeType

  """column name"""
  transactionHash

  """column name"""
  user_id
}

"""
order by stddev() on columns of table "Trade"
"""
input Trade_stddev_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
order by stddev_pop() on columns of table "Trade"
"""
input Trade_stddev_pop_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
order by stddev_samp() on columns of table "Trade"
"""
input Trade_stddev_samp_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
Streaming cursor of the table "Trade"
"""
input Trade_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Trade_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Trade_stream_cursor_value_input {
  db_write_timestamp: timestamp
  feeFormatted: String
  feeRaw: numeric
  id: String
  market_id: String
  newPriceFormatted: String
  newPriceRaw: numeric
  reserveAmountFormatted: String
  reserveAmountRaw: numeric
  timestamp: numeric
  tokenAmountFormatted: String
  tokenAmountRaw: numeric
  tradeType: tradetype
  transactionHash: String
  user_id: String
}

"""
order by sum() on columns of table "Trade"
"""
input Trade_sum_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
order by var_pop() on columns of table "Trade"
"""
input Trade_var_pop_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
order by var_samp() on columns of table "Trade"
"""
input Trade_var_samp_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
order by variance() on columns of table "Trade"
"""
input Trade_variance_order_by {
  feeRaw: order_by
  newPriceRaw: order_by
  reserveAmountRaw: order_by
  timestamp: order_by
  tokenAmountRaw: order_by
}

"""
columns and relationships of "Treasury"
"""
type Treasury {
  createdAt: numeric!
  db_write_timestamp: timestamp

  """An array relationship"""
  feeSplitterPayments(
    """distinct select on columns"""
    distinct_on: [FeeSplitterPayment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeSplitterPayment_order_by!]

    """filter the rows returned"""
    where: FeeSplitterPayment_bool_exp
  ): [FeeSplitterPayment!]!

  """An array relationship"""
  feeSplitterReceipts(
    """distinct select on columns"""
    distinct_on: [FeeSplitterReceipt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeSplitterReceipt_order_by!]

    """filter the rows returned"""
    where: FeeSplitterReceipt_bool_exp
  ): [FeeSplitterReceipt!]!
  id: String!
  lastUpdatedAt: numeric!
  market_id: String!
  totalFeesDistributedFormatted: String!
  totalFeesDistributedRaw: numeric!
  totalFeesReceivedFormatted: String!
  totalFeesReceivedRaw: numeric!
  treasuryAddress: String!
}

"""
Boolean expression to filter rows from the table "Treasury". All fields are combined with a logical 'AND'.
"""
input Treasury_bool_exp {
  _and: [Treasury_bool_exp!]
  _not: Treasury_bool_exp
  _or: [Treasury_bool_exp!]
  createdAt: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  feeSplitterPayments: FeeSplitterPayment_bool_exp
  feeSplitterReceipts: FeeSplitterReceipt_bool_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  market_id: String_comparison_exp
  totalFeesDistributedFormatted: String_comparison_exp
  totalFeesDistributedRaw: numeric_comparison_exp
  totalFeesReceivedFormatted: String_comparison_exp
  totalFeesReceivedRaw: numeric_comparison_exp
  treasuryAddress: String_comparison_exp
}

"""Ordering options when selecting data from "Treasury"."""
input Treasury_order_by {
  createdAt: order_by
  db_write_timestamp: order_by
  feeSplitterPayments_aggregate: FeeSplitterPayment_aggregate_order_by
  feeSplitterReceipts_aggregate: FeeSplitterReceipt_aggregate_order_by
  id: order_by
  lastUpdatedAt: order_by
  market_id: order_by
  totalFeesDistributedFormatted: order_by
  totalFeesDistributedRaw: order_by
  totalFeesReceivedFormatted: order_by
  totalFeesReceivedRaw: order_by
  treasuryAddress: order_by
}

"""
select columns of table "Treasury"
"""
enum Treasury_select_column {
  """column name"""
  createdAt

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  market_id

  """column name"""
  totalFeesDistributedFormatted

  """column name"""
  totalFeesDistributedRaw

  """column name"""
  totalFeesReceivedFormatted

  """column name"""
  totalFeesReceivedRaw

  """column name"""
  treasuryAddress
}

"""
Streaming cursor of the table "Treasury"
"""
input Treasury_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Treasury_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Treasury_stream_cursor_value_input {
  createdAt: numeric
  db_write_timestamp: timestamp
  id: String
  lastUpdatedAt: numeric
  market_id: String
  totalFeesDistributedFormatted: String
  totalFeesDistributedRaw: numeric
  totalFeesReceivedFormatted: String
  totalFeesReceivedRaw: numeric
  treasuryAddress: String
}

"""
columns and relationships of "UserMarketPosition"
"""
type UserMarketPosition {
  claimableRewardsFormatted: String!
  claimableRewardsRaw: numeric!
  db_write_timestamp: timestamp
  id: String!
  lastUpdatedAt: numeric!
  lockedCollateralFormatted: String!
  lockedCollateralRaw: numeric!
  market_id: String!
  netFTokenChangeFormatted: String!
  netFTokenChangeRaw: numeric!
  presaleDepositFormatted: String!
  presaleDepositRaw: numeric!
  presaleLeverage: numeric!
  stakedAmountFormatted: String!
  stakedAmountRaw: numeric!
  totalDebtFormatted: String!
  totalDebtRaw: numeric!
  user_id: String!
}

"""
order by aggregate values of table "UserMarketPosition"
"""
input UserMarketPosition_aggregate_order_by {
  avg: UserMarketPosition_avg_order_by
  count: order_by
  max: UserMarketPosition_max_order_by
  min: UserMarketPosition_min_order_by
  stddev: UserMarketPosition_stddev_order_by
  stddev_pop: UserMarketPosition_stddev_pop_order_by
  stddev_samp: UserMarketPosition_stddev_samp_order_by
  sum: UserMarketPosition_sum_order_by
  var_pop: UserMarketPosition_var_pop_order_by
  var_samp: UserMarketPosition_var_samp_order_by
  variance: UserMarketPosition_variance_order_by
}

"""
order by avg() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_avg_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
Boolean expression to filter rows from the table "UserMarketPosition". All fields are combined with a logical 'AND'.
"""
input UserMarketPosition_bool_exp {
  _and: [UserMarketPosition_bool_exp!]
  _not: UserMarketPosition_bool_exp
  _or: [UserMarketPosition_bool_exp!]
  claimableRewardsFormatted: String_comparison_exp
  claimableRewardsRaw: numeric_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  id: String_comparison_exp
  lastUpdatedAt: numeric_comparison_exp
  lockedCollateralFormatted: String_comparison_exp
  lockedCollateralRaw: numeric_comparison_exp
  market_id: String_comparison_exp
  netFTokenChangeFormatted: String_comparison_exp
  netFTokenChangeRaw: numeric_comparison_exp
  presaleDepositFormatted: String_comparison_exp
  presaleDepositRaw: numeric_comparison_exp
  presaleLeverage: numeric_comparison_exp
  stakedAmountFormatted: String_comparison_exp
  stakedAmountRaw: numeric_comparison_exp
  totalDebtFormatted: String_comparison_exp
  totalDebtRaw: numeric_comparison_exp
  user_id: String_comparison_exp
}

"""
order by max() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_max_order_by {
  claimableRewardsFormatted: order_by
  claimableRewardsRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  market_id: order_by
  netFTokenChangeFormatted: order_by
  netFTokenChangeRaw: order_by
  presaleDepositFormatted: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountFormatted: order_by
  stakedAmountRaw: order_by
  totalDebtFormatted: order_by
  totalDebtRaw: order_by
  user_id: order_by
}

"""
order by min() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_min_order_by {
  claimableRewardsFormatted: order_by
  claimableRewardsRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  market_id: order_by
  netFTokenChangeFormatted: order_by
  netFTokenChangeRaw: order_by
  presaleDepositFormatted: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountFormatted: order_by
  stakedAmountRaw: order_by
  totalDebtFormatted: order_by
  totalDebtRaw: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "UserMarketPosition"."""
input UserMarketPosition_order_by {
  claimableRewardsFormatted: order_by
  claimableRewardsRaw: order_by
  db_write_timestamp: order_by
  id: order_by
  lastUpdatedAt: order_by
  lockedCollateralFormatted: order_by
  lockedCollateralRaw: order_by
  market_id: order_by
  netFTokenChangeFormatted: order_by
  netFTokenChangeRaw: order_by
  presaleDepositFormatted: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountFormatted: order_by
  stakedAmountRaw: order_by
  totalDebtFormatted: order_by
  totalDebtRaw: order_by
  user_id: order_by
}

"""
select columns of table "UserMarketPosition"
"""
enum UserMarketPosition_select_column {
  """column name"""
  claimableRewardsFormatted

  """column name"""
  claimableRewardsRaw

  """column name"""
  db_write_timestamp

  """column name"""
  id

  """column name"""
  lastUpdatedAt

  """column name"""
  lockedCollateralFormatted

  """column name"""
  lockedCollateralRaw

  """column name"""
  market_id

  """column name"""
  netFTokenChangeFormatted

  """column name"""
  netFTokenChangeRaw

  """column name"""
  presaleDepositFormatted

  """column name"""
  presaleDepositRaw

  """column name"""
  presaleLeverage

  """column name"""
  stakedAmountFormatted

  """column name"""
  stakedAmountRaw

  """column name"""
  totalDebtFormatted

  """column name"""
  totalDebtRaw

  """column name"""
  user_id
}

"""
order by stddev() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_stddev_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
order by stddev_pop() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_stddev_pop_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
order by stddev_samp() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_stddev_samp_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
Streaming cursor of the table "UserMarketPosition"
"""
input UserMarketPosition_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: UserMarketPosition_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input UserMarketPosition_stream_cursor_value_input {
  claimableRewardsFormatted: String
  claimableRewardsRaw: numeric
  db_write_timestamp: timestamp
  id: String
  lastUpdatedAt: numeric
  lockedCollateralFormatted: String
  lockedCollateralRaw: numeric
  market_id: String
  netFTokenChangeFormatted: String
  netFTokenChangeRaw: numeric
  presaleDepositFormatted: String
  presaleDepositRaw: numeric
  presaleLeverage: numeric
  stakedAmountFormatted: String
  stakedAmountRaw: numeric
  totalDebtFormatted: String
  totalDebtRaw: numeric
  user_id: String
}

"""
order by sum() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_sum_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
order by var_pop() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_var_pop_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
order by var_samp() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_var_samp_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

"""
order by variance() on columns of table "UserMarketPosition"
"""
input UserMarketPosition_variance_order_by {
  claimableRewardsRaw: order_by
  lastUpdatedAt: order_by
  lockedCollateralRaw: order_by
  netFTokenChangeRaw: order_by
  presaleDepositRaw: order_by
  presaleLeverage: order_by
  stakedAmountRaw: order_by
  totalDebtRaw: order_by
}

scalar candleperiod

"""
Boolean expression to compare columns of type "candleperiod". All fields are combined with logical 'AND'.
"""
input candleperiod_comparison_exp {
  _eq: candleperiod
  _gt: candleperiod
  _gte: candleperiod
  _in: [candleperiod!]
  _is_null: Boolean
  _lt: candleperiod
  _lte: candleperiod
  _neq: candleperiod
  _nin: [candleperiod!]
}

"""
columns and relationships of "chain_metadata"
"""
type chain_metadata {
  block_height: Int!
  chain_id: Int!
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean!
  latest_fetched_block_number: Int!
  latest_processed_block: Int
  num_batches_fetched: Int!
  num_events_processed: Int
  start_block: Int!
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

"""
Boolean expression to filter rows from the table "chain_metadata". All fields are combined with a logical 'AND'.
"""
input chain_metadata_bool_exp {
  _and: [chain_metadata_bool_exp!]
  _not: chain_metadata_bool_exp
  _or: [chain_metadata_bool_exp!]
  block_height: Int_comparison_exp
  chain_id: Int_comparison_exp
  end_block: Int_comparison_exp
  first_event_block_number: Int_comparison_exp
  is_hyper_sync: Boolean_comparison_exp
  latest_fetched_block_number: Int_comparison_exp
  latest_processed_block: Int_comparison_exp
  num_batches_fetched: Int_comparison_exp
  num_events_processed: Int_comparison_exp
  start_block: Int_comparison_exp
  timestamp_caught_up_to_head_or_endblock: timestamptz_comparison_exp
}

"""Ordering options when selecting data from "chain_metadata"."""
input chain_metadata_order_by {
  block_height: order_by
  chain_id: order_by
  end_block: order_by
  first_event_block_number: order_by
  is_hyper_sync: order_by
  latest_fetched_block_number: order_by
  latest_processed_block: order_by
  num_batches_fetched: order_by
  num_events_processed: order_by
  start_block: order_by
  timestamp_caught_up_to_head_or_endblock: order_by
}

"""
select columns of table "chain_metadata"
"""
enum chain_metadata_select_column {
  """column name"""
  block_height

  """column name"""
  chain_id

  """column name"""
  end_block

  """column name"""
  first_event_block_number

  """column name"""
  is_hyper_sync

  """column name"""
  latest_fetched_block_number

  """column name"""
  latest_processed_block

  """column name"""
  num_batches_fetched

  """column name"""
  num_events_processed

  """column name"""
  start_block

  """column name"""
  timestamp_caught_up_to_head_or_endblock
}

"""
Streaming cursor of the table "chain_metadata"
"""
input chain_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chain_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chain_metadata_stream_cursor_value_input {
  block_height: Int
  chain_id: Int
  end_block: Int
  first_event_block_number: Int
  is_hyper_sync: Boolean
  latest_fetched_block_number: Int
  latest_processed_block: Int
  num_batches_fetched: Int
  num_events_processed: Int
  start_block: Int
  timestamp_caught_up_to_head_or_endblock: timestamptz
}

scalar contract_type

"""
Boolean expression to compare columns of type "contract_type". All fields are combined with logical 'AND'.
"""
input contract_type_comparison_exp {
  _eq: contract_type
  _gt: contract_type
  _gte: contract_type
  _in: [contract_type!]
  _is_null: Boolean
  _lt: contract_type
  _lte: contract_type
  _neq: contract_type
  _nin: [contract_type!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "dynamic_contract_registry"
"""
type dynamic_contract_registry {
  chain_id: Int!
  contract_address: String!
  contract_type: contract_type!
  id: String!
  registering_event_block_number: Int!
  registering_event_block_timestamp: Int!
  registering_event_contract_name: String!
  registering_event_log_index: Int!
  registering_event_name: String!
  registering_event_src_address: String!
}

"""
Boolean expression to filter rows from the table "dynamic_contract_registry". All fields are combined with a logical 'AND'.
"""
input dynamic_contract_registry_bool_exp {
  _and: [dynamic_contract_registry_bool_exp!]
  _not: dynamic_contract_registry_bool_exp
  _or: [dynamic_contract_registry_bool_exp!]
  chain_id: Int_comparison_exp
  contract_address: String_comparison_exp
  contract_type: contract_type_comparison_exp
  id: String_comparison_exp
  registering_event_block_number: Int_comparison_exp
  registering_event_block_timestamp: Int_comparison_exp
  registering_event_contract_name: String_comparison_exp
  registering_event_log_index: Int_comparison_exp
  registering_event_name: String_comparison_exp
  registering_event_src_address: String_comparison_exp
}

"""Ordering options when selecting data from "dynamic_contract_registry"."""
input dynamic_contract_registry_order_by {
  chain_id: order_by
  contract_address: order_by
  contract_type: order_by
  id: order_by
  registering_event_block_number: order_by
  registering_event_block_timestamp: order_by
  registering_event_contract_name: order_by
  registering_event_log_index: order_by
  registering_event_name: order_by
  registering_event_src_address: order_by
}

"""
select columns of table "dynamic_contract_registry"
"""
enum dynamic_contract_registry_select_column {
  """column name"""
  chain_id

  """column name"""
  contract_address

  """column name"""
  contract_type

  """column name"""
  id

  """column name"""
  registering_event_block_number

  """column name"""
  registering_event_block_timestamp

  """column name"""
  registering_event_contract_name

  """column name"""
  registering_event_log_index

  """column name"""
  registering_event_name

  """column name"""
  registering_event_src_address
}

"""
Streaming cursor of the table "dynamic_contract_registry"
"""
input dynamic_contract_registry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: dynamic_contract_registry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input dynamic_contract_registry_stream_cursor_value_input {
  chain_id: Int
  contract_address: String
  contract_type: contract_type
  id: String
  registering_event_block_number: Int
  registering_event_block_timestamp: Int
  registering_event_contract_name: String
  registering_event_log_index: Int
  registering_event_name: String
  registering_event_src_address: String
}

"""
columns and relationships of "end_of_block_range_scanned_data"
"""
type end_of_block_range_scanned_data {
  block_hash: String!
  block_number: Int!
  chain_id: Int!
}

"""
Boolean expression to filter rows from the table "end_of_block_range_scanned_data". All fields are combined with a logical 'AND'.
"""
input end_of_block_range_scanned_data_bool_exp {
  _and: [end_of_block_range_scanned_data_bool_exp!]
  _not: end_of_block_range_scanned_data_bool_exp
  _or: [end_of_block_range_scanned_data_bool_exp!]
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  chain_id: Int_comparison_exp
}

"""
Ordering options when selecting data from "end_of_block_range_scanned_data".
"""
input end_of_block_range_scanned_data_order_by {
  block_hash: order_by
  block_number: order_by
  chain_id: order_by
}

"""
select columns of table "end_of_block_range_scanned_data"
"""
enum end_of_block_range_scanned_data_select_column {
  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  chain_id
}

"""
Streaming cursor of the table "end_of_block_range_scanned_data"
"""
input end_of_block_range_scanned_data_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: end_of_block_range_scanned_data_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input end_of_block_range_scanned_data_stream_cursor_value_input {
  block_hash: String
  block_number: Int
  chain_id: Int
}

"""
columns and relationships of "event_sync_state"
"""
type event_sync_state {
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  is_pre_registering_dynamic_contracts: Boolean
  log_index: Int!
}

"""
Boolean expression to filter rows from the table "event_sync_state". All fields are combined with a logical 'AND'.
"""
input event_sync_state_bool_exp {
  _and: [event_sync_state_bool_exp!]
  _not: event_sync_state_bool_exp
  _or: [event_sync_state_bool_exp!]
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  is_pre_registering_dynamic_contracts: Boolean_comparison_exp
  log_index: Int_comparison_exp
}

"""Ordering options when selecting data from "event_sync_state"."""
input event_sync_state_order_by {
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  is_pre_registering_dynamic_contracts: order_by
  log_index: order_by
}

"""
select columns of table "event_sync_state"
"""
enum event_sync_state_select_column {
  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  is_pre_registering_dynamic_contracts

  """column name"""
  log_index
}

"""
Streaming cursor of the table "event_sync_state"
"""
input event_sync_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_sync_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_sync_state_stream_cursor_value_input {
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  is_pre_registering_dynamic_contracts: Boolean
  log_index: Int
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

scalar loanstatus

"""
Boolean expression to compare columns of type "loanstatus". All fields are combined with logical 'AND'.
"""
input loanstatus_comparison_exp {
  _eq: loanstatus
  _gt: loanstatus
  _gte: loanstatus
  _in: [loanstatus!]
  _is_null: Boolean
  _lt: loanstatus
  _lte: loanstatus
  _neq: loanstatus
  _nin: [loanstatus!]
}

scalar marketstatus

"""
Boolean expression to compare columns of type "marketstatus". All fields are combined with logical 'AND'.
"""
input marketstatus_comparison_exp {
  _eq: marketstatus
  _gt: marketstatus
  _gte: marketstatus
  _in: [marketstatus!]
  _is_null: Boolean
  _lt: marketstatus
  _lte: marketstatus
  _neq: marketstatus
  _nin: [marketstatus!]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [numeric!]

  """does the array contain the given value"""
  _contains: [numeric!]
  _eq: [numeric!]
  _gt: [numeric!]
  _gte: [numeric!]
  _in: [[numeric!]!]
  _is_null: Boolean
  _lt: [numeric!]
  _lte: [numeric!]
  _neq: [numeric!]
  _nin: [[numeric!]!]
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "persisted_state"
"""
type persisted_state {
  abi_files_hash: String!
  config_hash: String!
  envio_version: String!
  handler_files_hash: String!
  id: Int!
  schema_hash: String!
}

"""
Boolean expression to filter rows from the table "persisted_state". All fields are combined with a logical 'AND'.
"""
input persisted_state_bool_exp {
  _and: [persisted_state_bool_exp!]
  _not: persisted_state_bool_exp
  _or: [persisted_state_bool_exp!]
  abi_files_hash: String_comparison_exp
  config_hash: String_comparison_exp
  envio_version: String_comparison_exp
  handler_files_hash: String_comparison_exp
  id: Int_comparison_exp
  schema_hash: String_comparison_exp
}

"""Ordering options when selecting data from "persisted_state"."""
input persisted_state_order_by {
  abi_files_hash: order_by
  config_hash: order_by
  envio_version: order_by
  handler_files_hash: order_by
  id: order_by
  schema_hash: order_by
}

"""
select columns of table "persisted_state"
"""
enum persisted_state_select_column {
  """column name"""
  abi_files_hash

  """column name"""
  config_hash

  """column name"""
  envio_version

  """column name"""
  handler_files_hash

  """column name"""
  id

  """column name"""
  schema_hash
}

"""
Streaming cursor of the table "persisted_state"
"""
input persisted_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: persisted_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input persisted_state_stream_cursor_value_input {
  abi_files_hash: String
  config_hash: String
  envio_version: String
  handler_files_hash: String
  id: Int
  schema_hash: String
}

scalar presaleclaimtype

"""
Boolean expression to compare columns of type "presaleclaimtype". All fields are combined with logical 'AND'.
"""
input presaleclaimtype_comparison_exp {
  _eq: presaleclaimtype
  _gt: presaleclaimtype
  _gte: presaleclaimtype
  _in: [presaleclaimtype!]
  _is_null: Boolean
  _lt: presaleclaimtype
  _lte: presaleclaimtype
  _neq: presaleclaimtype
  _nin: [presaleclaimtype!]
}

type query_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: String!): Account

  """
  fetch data from the table: "AuthorizerContract"
  """
  AuthorizerContract(
    """distinct select on columns"""
    distinct_on: [AuthorizerContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AuthorizerContract_order_by!]

    """filter the rows returned"""
    where: AuthorizerContract_bool_exp
  ): [AuthorizerContract!]!

  """
  fetch data from the table: "AuthorizerContract" using primary key columns
  """
  AuthorizerContract_by_pk(id: String!): AuthorizerContract

  """
  fetch data from the table: "CreditFacilityContract"
  """
  CreditFacilityContract(
    """distinct select on columns"""
    distinct_on: [CreditFacilityContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CreditFacilityContract_order_by!]

    """filter the rows returned"""
    where: CreditFacilityContract_bool_exp
  ): [CreditFacilityContract!]!

  """
  fetch data from the table: "CreditFacilityContract" using primary key columns
  """
  CreditFacilityContract_by_pk(id: String!): CreditFacilityContract

  """
  fetch data from the table: "FeeSplitterPayment"
  """
  FeeSplitterPayment(
    """distinct select on columns"""
    distinct_on: [FeeSplitterPayment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeSplitterPayment_order_by!]

    """filter the rows returned"""
    where: FeeSplitterPayment_bool_exp
  ): [FeeSplitterPayment!]!

  """
  fetch data from the table: "FeeSplitterPayment" using primary key columns
  """
  FeeSplitterPayment_by_pk(id: String!): FeeSplitterPayment

  """
  fetch data from the table: "FeeSplitterReceipt"
  """
  FeeSplitterReceipt(
    """distinct select on columns"""
    distinct_on: [FeeSplitterReceipt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeSplitterReceipt_order_by!]

    """filter the rows returned"""
    where: FeeSplitterReceipt_bool_exp
  ): [FeeSplitterReceipt!]!

  """
  fetch data from the table: "FeeSplitterReceipt" using primary key columns
  """
  FeeSplitterReceipt_by_pk(id: String!): FeeSplitterReceipt

  """
  fetch data from the table: "FloorElevation"
  """
  FloorElevation(
    """distinct select on columns"""
    distinct_on: [FloorElevation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FloorElevation_order_by!]

    """filter the rows returned"""
    where: FloorElevation_bool_exp
  ): [FloorElevation!]!

  """fetch data from the table: "FloorElevation" using primary key columns"""
  FloorElevation_by_pk(id: String!): FloorElevation

  """
  fetch data from the table: "GlobalRegistry"
  """
  GlobalRegistry(
    """distinct select on columns"""
    distinct_on: [GlobalRegistry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [GlobalRegistry_order_by!]

    """filter the rows returned"""
    where: GlobalRegistry_bool_exp
  ): [GlobalRegistry!]!

  """fetch data from the table: "GlobalRegistry" using primary key columns"""
  GlobalRegistry_by_pk(id: String!): GlobalRegistry

  """
  fetch data from the table: "GlobalStats"
  """
  GlobalStats(
    """distinct select on columns"""
    distinct_on: [GlobalStats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [GlobalStats_order_by!]

    """filter the rows returned"""
    where: GlobalStats_bool_exp
  ): [GlobalStats!]!

  """fetch data from the table: "GlobalStats" using primary key columns"""
  GlobalStats_by_pk(id: String!): GlobalStats

  """
  fetch data from the table: "Loan"
  """
  Loan(
    """distinct select on columns"""
    distinct_on: [Loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Loan_order_by!]

    """filter the rows returned"""
    where: Loan_bool_exp
  ): [Loan!]!

  """
  fetch data from the table: "LoanStatusHistory"
  """
  LoanStatusHistory(
    """distinct select on columns"""
    distinct_on: [LoanStatusHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LoanStatusHistory_order_by!]

    """filter the rows returned"""
    where: LoanStatusHistory_bool_exp
  ): [LoanStatusHistory!]!

  """
  fetch data from the table: "LoanStatusHistory" using primary key columns
  """
  LoanStatusHistory_by_pk(id: String!): LoanStatusHistory

  """fetch data from the table: "Loan" using primary key columns"""
  Loan_by_pk(id: String!): Loan

  """
  fetch data from the table: "Market"
  """
  Market(
    """distinct select on columns"""
    distinct_on: [Market_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Market_order_by!]

    """filter the rows returned"""
    where: Market_bool_exp
  ): [Market!]!

  """
  fetch data from the table: "MarketRollingStats"
  """
  MarketRollingStats(
    """distinct select on columns"""
    distinct_on: [MarketRollingStats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MarketRollingStats_order_by!]

    """filter the rows returned"""
    where: MarketRollingStats_bool_exp
  ): [MarketRollingStats!]!

  """
  fetch data from the table: "MarketRollingStats" using primary key columns
  """
  MarketRollingStats_by_pk(id: String!): MarketRollingStats

  """
  fetch data from the table: "MarketSnapshot"
  """
  MarketSnapshot(
    """distinct select on columns"""
    distinct_on: [MarketSnapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MarketSnapshot_order_by!]

    """filter the rows returned"""
    where: MarketSnapshot_bool_exp
  ): [MarketSnapshot!]!

  """fetch data from the table: "MarketSnapshot" using primary key columns"""
  MarketSnapshot_by_pk(id: String!): MarketSnapshot

  """fetch data from the table: "Market" using primary key columns"""
  Market_by_pk(id: String!): Market

  """
  fetch data from the table: "ModuleAddress"
  """
  ModuleAddress(
    """distinct select on columns"""
    distinct_on: [ModuleAddress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ModuleAddress_order_by!]

    """filter the rows returned"""
    where: ModuleAddress_bool_exp
  ): [ModuleAddress!]!

  """fetch data from the table: "ModuleAddress" using primary key columns"""
  ModuleAddress_by_pk(id: String!): ModuleAddress

  """
  fetch data from the table: "ModuleRegistry"
  """
  ModuleRegistry(
    """distinct select on columns"""
    distinct_on: [ModuleRegistry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ModuleRegistry_order_by!]

    """filter the rows returned"""
    where: ModuleRegistry_bool_exp
  ): [ModuleRegistry!]!

  """fetch data from the table: "ModuleRegistry" using primary key columns"""
  ModuleRegistry_by_pk(id: String!): ModuleRegistry

  """
  fetch data from the table: "PreSaleContract"
  """
  PreSaleContract(
    """distinct select on columns"""
    distinct_on: [PreSaleContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PreSaleContract_order_by!]

    """filter the rows returned"""
    where: PreSaleContract_bool_exp
  ): [PreSaleContract!]!

  """fetch data from the table: "PreSaleContract" using primary key columns"""
  PreSaleContract_by_pk(id: String!): PreSaleContract

  """
  fetch data from the table: "PresaleClaim"
  """
  PresaleClaim(
    """distinct select on columns"""
    distinct_on: [PresaleClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleClaim_order_by!]

    """filter the rows returned"""
    where: PresaleClaim_bool_exp
  ): [PresaleClaim!]!

  """fetch data from the table: "PresaleClaim" using primary key columns"""
  PresaleClaim_by_pk(id: String!): PresaleClaim

  """
  fetch data from the table: "PresaleParticipation"
  """
  PresaleParticipation(
    """distinct select on columns"""
    distinct_on: [PresaleParticipation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleParticipation_order_by!]

    """filter the rows returned"""
    where: PresaleParticipation_bool_exp
  ): [PresaleParticipation!]!

  """
  fetch data from the table: "PresaleParticipation" using primary key columns
  """
  PresaleParticipation_by_pk(id: String!): PresaleParticipation

  """
  fetch data from the table: "PriceCandle"
  """
  PriceCandle(
    """distinct select on columns"""
    distinct_on: [PriceCandle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PriceCandle_order_by!]

    """filter the rows returned"""
    where: PriceCandle_bool_exp
  ): [PriceCandle!]!

  """fetch data from the table: "PriceCandle" using primary key columns"""
  PriceCandle_by_pk(id: String!): PriceCandle

  """
  fetch data from the table: "Role"
  """
  Role(
    """distinct select on columns"""
    distinct_on: [Role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Role_order_by!]

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """
  fetch data from the table: "RoleMember"
  """
  RoleMember(
    """distinct select on columns"""
    distinct_on: [RoleMember_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [RoleMember_order_by!]

    """filter the rows returned"""
    where: RoleMember_bool_exp
  ): [RoleMember!]!

  """fetch data from the table: "RoleMember" using primary key columns"""
  RoleMember_by_pk(id: String!): RoleMember

  """
  fetch data from the table: "RolePermission"
  """
  RolePermission(
    """distinct select on columns"""
    distinct_on: [RolePermission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [RolePermission_order_by!]

    """filter the rows returned"""
    where: RolePermission_bool_exp
  ): [RolePermission!]!

  """fetch data from the table: "RolePermission" using primary key columns"""
  RolePermission_by_pk(id: String!): RolePermission

  """fetch data from the table: "Role" using primary key columns"""
  Role_by_pk(id: String!): Role

  """
  fetch data from the table: "Stake"
  """
  Stake(
    """distinct select on columns"""
    distinct_on: [Stake_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Stake_order_by!]

    """filter the rows returned"""
    where: Stake_bool_exp
  ): [Stake!]!

  """fetch data from the table: "Stake" using primary key columns"""
  Stake_by_pk(id: String!): Stake

  """
  fetch data from the table: "StakingContract"
  """
  StakingContract(
    """distinct select on columns"""
    distinct_on: [StakingContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StakingContract_order_by!]

    """filter the rows returned"""
    where: StakingContract_bool_exp
  ): [StakingContract!]!

  """fetch data from the table: "StakingContract" using primary key columns"""
  StakingContract_by_pk(id: String!): StakingContract

  """
  fetch data from the table: "Token"
  """
  Token(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """fetch data from the table: "Token" using primary key columns"""
  Token_by_pk(id: String!): Token

  """
  fetch data from the table: "Trade"
  """
  Trade(
    """distinct select on columns"""
    distinct_on: [Trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Trade_order_by!]

    """filter the rows returned"""
    where: Trade_bool_exp
  ): [Trade!]!

  """fetch data from the table: "Trade" using primary key columns"""
  Trade_by_pk(id: String!): Trade

  """
  fetch data from the table: "Treasury"
  """
  Treasury(
    """distinct select on columns"""
    distinct_on: [Treasury_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Treasury_order_by!]

    """filter the rows returned"""
    where: Treasury_bool_exp
  ): [Treasury!]!

  """fetch data from the table: "Treasury" using primary key columns"""
  Treasury_by_pk(id: String!): Treasury

  """
  fetch data from the table: "UserMarketPosition"
  """
  UserMarketPosition(
    """distinct select on columns"""
    distinct_on: [UserMarketPosition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserMarketPosition_order_by!]

    """filter the rows returned"""
    where: UserMarketPosition_bool_exp
  ): [UserMarketPosition!]!

  """
  fetch data from the table: "UserMarketPosition" using primary key columns
  """
  UserMarketPosition_by_pk(id: String!): UserMarketPosition

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(id: String!): dynamic_contract_registry

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(serial: Int!): raw_events
}

"""
columns and relationships of "raw_events"
"""
type raw_events {
  block_fields(
    """JSON select path"""
    path: String
  ): jsonb!
  block_hash: String!
  block_number: Int!
  block_timestamp: Int!
  chain_id: Int!
  contract_name: String!
  db_write_timestamp: timestamp
  event_id: numeric!
  event_name: String!
  log_index: Int!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
  serial: Int!
  src_address: String!
  transaction_fields(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
Boolean expression to filter rows from the table "raw_events". All fields are combined with a logical 'AND'.
"""
input raw_events_bool_exp {
  _and: [raw_events_bool_exp!]
  _not: raw_events_bool_exp
  _or: [raw_events_bool_exp!]
  block_fields: jsonb_comparison_exp
  block_hash: String_comparison_exp
  block_number: Int_comparison_exp
  block_timestamp: Int_comparison_exp
  chain_id: Int_comparison_exp
  contract_name: String_comparison_exp
  db_write_timestamp: timestamp_comparison_exp
  event_id: numeric_comparison_exp
  event_name: String_comparison_exp
  log_index: Int_comparison_exp
  params: jsonb_comparison_exp
  serial: Int_comparison_exp
  src_address: String_comparison_exp
  transaction_fields: jsonb_comparison_exp
}

"""Ordering options when selecting data from "raw_events"."""
input raw_events_order_by {
  block_fields: order_by
  block_hash: order_by
  block_number: order_by
  block_timestamp: order_by
  chain_id: order_by
  contract_name: order_by
  db_write_timestamp: order_by
  event_id: order_by
  event_name: order_by
  log_index: order_by
  params: order_by
  serial: order_by
  src_address: order_by
  transaction_fields: order_by
}

"""
select columns of table "raw_events"
"""
enum raw_events_select_column {
  """column name"""
  block_fields

  """column name"""
  block_hash

  """column name"""
  block_number

  """column name"""
  block_timestamp

  """column name"""
  chain_id

  """column name"""
  contract_name

  """column name"""
  db_write_timestamp

  """column name"""
  event_id

  """column name"""
  event_name

  """column name"""
  log_index

  """column name"""
  params

  """column name"""
  serial

  """column name"""
  src_address

  """column name"""
  transaction_fields
}

"""
Streaming cursor of the table "raw_events"
"""
input raw_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: raw_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input raw_events_stream_cursor_value_input {
  block_fields: jsonb
  block_hash: String
  block_number: Int
  block_timestamp: Int
  chain_id: Int
  contract_name: String
  db_write_timestamp: timestamp
  event_id: numeric
  event_name: String
  log_index: Int
  params: jsonb
  serial: Int
  src_address: String
  transaction_fields: jsonb
}

scalar stakestatus

"""
Boolean expression to compare columns of type "stakestatus". All fields are combined with logical 'AND'.
"""
input stakestatus_comparison_exp {
  _eq: stakestatus
  _gt: stakestatus
  _gte: stakestatus
  _in: [stakestatus!]
  _is_null: Boolean
  _lt: stakestatus
  _lte: stakestatus
  _neq: stakestatus
  _nin: [stakestatus!]
}

type subscription_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: String!): Account

  """
  fetch data from the table in a streaming manner: "Account"
  """
  Account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Account_stream_cursor_input]!

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch data from the table: "AuthorizerContract"
  """
  AuthorizerContract(
    """distinct select on columns"""
    distinct_on: [AuthorizerContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AuthorizerContract_order_by!]

    """filter the rows returned"""
    where: AuthorizerContract_bool_exp
  ): [AuthorizerContract!]!

  """
  fetch data from the table: "AuthorizerContract" using primary key columns
  """
  AuthorizerContract_by_pk(id: String!): AuthorizerContract

  """
  fetch data from the table in a streaming manner: "AuthorizerContract"
  """
  AuthorizerContract_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuthorizerContract_stream_cursor_input]!

    """filter the rows returned"""
    where: AuthorizerContract_bool_exp
  ): [AuthorizerContract!]!

  """
  fetch data from the table: "CreditFacilityContract"
  """
  CreditFacilityContract(
    """distinct select on columns"""
    distinct_on: [CreditFacilityContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [CreditFacilityContract_order_by!]

    """filter the rows returned"""
    where: CreditFacilityContract_bool_exp
  ): [CreditFacilityContract!]!

  """
  fetch data from the table: "CreditFacilityContract" using primary key columns
  """
  CreditFacilityContract_by_pk(id: String!): CreditFacilityContract

  """
  fetch data from the table in a streaming manner: "CreditFacilityContract"
  """
  CreditFacilityContract_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CreditFacilityContract_stream_cursor_input]!

    """filter the rows returned"""
    where: CreditFacilityContract_bool_exp
  ): [CreditFacilityContract!]!

  """
  fetch data from the table: "FeeSplitterPayment"
  """
  FeeSplitterPayment(
    """distinct select on columns"""
    distinct_on: [FeeSplitterPayment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeSplitterPayment_order_by!]

    """filter the rows returned"""
    where: FeeSplitterPayment_bool_exp
  ): [FeeSplitterPayment!]!

  """
  fetch data from the table: "FeeSplitterPayment" using primary key columns
  """
  FeeSplitterPayment_by_pk(id: String!): FeeSplitterPayment

  """
  fetch data from the table in a streaming manner: "FeeSplitterPayment"
  """
  FeeSplitterPayment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [FeeSplitterPayment_stream_cursor_input]!

    """filter the rows returned"""
    where: FeeSplitterPayment_bool_exp
  ): [FeeSplitterPayment!]!

  """
  fetch data from the table: "FeeSplitterReceipt"
  """
  FeeSplitterReceipt(
    """distinct select on columns"""
    distinct_on: [FeeSplitterReceipt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FeeSplitterReceipt_order_by!]

    """filter the rows returned"""
    where: FeeSplitterReceipt_bool_exp
  ): [FeeSplitterReceipt!]!

  """
  fetch data from the table: "FeeSplitterReceipt" using primary key columns
  """
  FeeSplitterReceipt_by_pk(id: String!): FeeSplitterReceipt

  """
  fetch data from the table in a streaming manner: "FeeSplitterReceipt"
  """
  FeeSplitterReceipt_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [FeeSplitterReceipt_stream_cursor_input]!

    """filter the rows returned"""
    where: FeeSplitterReceipt_bool_exp
  ): [FeeSplitterReceipt!]!

  """
  fetch data from the table: "FloorElevation"
  """
  FloorElevation(
    """distinct select on columns"""
    distinct_on: [FloorElevation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [FloorElevation_order_by!]

    """filter the rows returned"""
    where: FloorElevation_bool_exp
  ): [FloorElevation!]!

  """fetch data from the table: "FloorElevation" using primary key columns"""
  FloorElevation_by_pk(id: String!): FloorElevation

  """
  fetch data from the table in a streaming manner: "FloorElevation"
  """
  FloorElevation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [FloorElevation_stream_cursor_input]!

    """filter the rows returned"""
    where: FloorElevation_bool_exp
  ): [FloorElevation!]!

  """
  fetch data from the table: "GlobalRegistry"
  """
  GlobalRegistry(
    """distinct select on columns"""
    distinct_on: [GlobalRegistry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [GlobalRegistry_order_by!]

    """filter the rows returned"""
    where: GlobalRegistry_bool_exp
  ): [GlobalRegistry!]!

  """fetch data from the table: "GlobalRegistry" using primary key columns"""
  GlobalRegistry_by_pk(id: String!): GlobalRegistry

  """
  fetch data from the table in a streaming manner: "GlobalRegistry"
  """
  GlobalRegistry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GlobalRegistry_stream_cursor_input]!

    """filter the rows returned"""
    where: GlobalRegistry_bool_exp
  ): [GlobalRegistry!]!

  """
  fetch data from the table: "GlobalStats"
  """
  GlobalStats(
    """distinct select on columns"""
    distinct_on: [GlobalStats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [GlobalStats_order_by!]

    """filter the rows returned"""
    where: GlobalStats_bool_exp
  ): [GlobalStats!]!

  """fetch data from the table: "GlobalStats" using primary key columns"""
  GlobalStats_by_pk(id: String!): GlobalStats

  """
  fetch data from the table in a streaming manner: "GlobalStats"
  """
  GlobalStats_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GlobalStats_stream_cursor_input]!

    """filter the rows returned"""
    where: GlobalStats_bool_exp
  ): [GlobalStats!]!

  """
  fetch data from the table: "Loan"
  """
  Loan(
    """distinct select on columns"""
    distinct_on: [Loan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Loan_order_by!]

    """filter the rows returned"""
    where: Loan_bool_exp
  ): [Loan!]!

  """
  fetch data from the table: "LoanStatusHistory"
  """
  LoanStatusHistory(
    """distinct select on columns"""
    distinct_on: [LoanStatusHistory_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [LoanStatusHistory_order_by!]

    """filter the rows returned"""
    where: LoanStatusHistory_bool_exp
  ): [LoanStatusHistory!]!

  """
  fetch data from the table: "LoanStatusHistory" using primary key columns
  """
  LoanStatusHistory_by_pk(id: String!): LoanStatusHistory

  """
  fetch data from the table in a streaming manner: "LoanStatusHistory"
  """
  LoanStatusHistory_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LoanStatusHistory_stream_cursor_input]!

    """filter the rows returned"""
    where: LoanStatusHistory_bool_exp
  ): [LoanStatusHistory!]!

  """fetch data from the table: "Loan" using primary key columns"""
  Loan_by_pk(id: String!): Loan

  """
  fetch data from the table in a streaming manner: "Loan"
  """
  Loan_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Loan_stream_cursor_input]!

    """filter the rows returned"""
    where: Loan_bool_exp
  ): [Loan!]!

  """
  fetch data from the table: "Market"
  """
  Market(
    """distinct select on columns"""
    distinct_on: [Market_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Market_order_by!]

    """filter the rows returned"""
    where: Market_bool_exp
  ): [Market!]!

  """
  fetch data from the table: "MarketRollingStats"
  """
  MarketRollingStats(
    """distinct select on columns"""
    distinct_on: [MarketRollingStats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MarketRollingStats_order_by!]

    """filter the rows returned"""
    where: MarketRollingStats_bool_exp
  ): [MarketRollingStats!]!

  """
  fetch data from the table: "MarketRollingStats" using primary key columns
  """
  MarketRollingStats_by_pk(id: String!): MarketRollingStats

  """
  fetch data from the table in a streaming manner: "MarketRollingStats"
  """
  MarketRollingStats_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MarketRollingStats_stream_cursor_input]!

    """filter the rows returned"""
    where: MarketRollingStats_bool_exp
  ): [MarketRollingStats!]!

  """
  fetch data from the table: "MarketSnapshot"
  """
  MarketSnapshot(
    """distinct select on columns"""
    distinct_on: [MarketSnapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [MarketSnapshot_order_by!]

    """filter the rows returned"""
    where: MarketSnapshot_bool_exp
  ): [MarketSnapshot!]!

  """fetch data from the table: "MarketSnapshot" using primary key columns"""
  MarketSnapshot_by_pk(id: String!): MarketSnapshot

  """
  fetch data from the table in a streaming manner: "MarketSnapshot"
  """
  MarketSnapshot_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MarketSnapshot_stream_cursor_input]!

    """filter the rows returned"""
    where: MarketSnapshot_bool_exp
  ): [MarketSnapshot!]!

  """fetch data from the table: "Market" using primary key columns"""
  Market_by_pk(id: String!): Market

  """
  fetch data from the table in a streaming manner: "Market"
  """
  Market_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Market_stream_cursor_input]!

    """filter the rows returned"""
    where: Market_bool_exp
  ): [Market!]!

  """
  fetch data from the table: "ModuleAddress"
  """
  ModuleAddress(
    """distinct select on columns"""
    distinct_on: [ModuleAddress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ModuleAddress_order_by!]

    """filter the rows returned"""
    where: ModuleAddress_bool_exp
  ): [ModuleAddress!]!

  """fetch data from the table: "ModuleAddress" using primary key columns"""
  ModuleAddress_by_pk(id: String!): ModuleAddress

  """
  fetch data from the table in a streaming manner: "ModuleAddress"
  """
  ModuleAddress_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ModuleAddress_stream_cursor_input]!

    """filter the rows returned"""
    where: ModuleAddress_bool_exp
  ): [ModuleAddress!]!

  """
  fetch data from the table: "ModuleRegistry"
  """
  ModuleRegistry(
    """distinct select on columns"""
    distinct_on: [ModuleRegistry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ModuleRegistry_order_by!]

    """filter the rows returned"""
    where: ModuleRegistry_bool_exp
  ): [ModuleRegistry!]!

  """fetch data from the table: "ModuleRegistry" using primary key columns"""
  ModuleRegistry_by_pk(id: String!): ModuleRegistry

  """
  fetch data from the table in a streaming manner: "ModuleRegistry"
  """
  ModuleRegistry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ModuleRegistry_stream_cursor_input]!

    """filter the rows returned"""
    where: ModuleRegistry_bool_exp
  ): [ModuleRegistry!]!

  """
  fetch data from the table: "PreSaleContract"
  """
  PreSaleContract(
    """distinct select on columns"""
    distinct_on: [PreSaleContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PreSaleContract_order_by!]

    """filter the rows returned"""
    where: PreSaleContract_bool_exp
  ): [PreSaleContract!]!

  """fetch data from the table: "PreSaleContract" using primary key columns"""
  PreSaleContract_by_pk(id: String!): PreSaleContract

  """
  fetch data from the table in a streaming manner: "PreSaleContract"
  """
  PreSaleContract_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PreSaleContract_stream_cursor_input]!

    """filter the rows returned"""
    where: PreSaleContract_bool_exp
  ): [PreSaleContract!]!

  """
  fetch data from the table: "PresaleClaim"
  """
  PresaleClaim(
    """distinct select on columns"""
    distinct_on: [PresaleClaim_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleClaim_order_by!]

    """filter the rows returned"""
    where: PresaleClaim_bool_exp
  ): [PresaleClaim!]!

  """fetch data from the table: "PresaleClaim" using primary key columns"""
  PresaleClaim_by_pk(id: String!): PresaleClaim

  """
  fetch data from the table in a streaming manner: "PresaleClaim"
  """
  PresaleClaim_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PresaleClaim_stream_cursor_input]!

    """filter the rows returned"""
    where: PresaleClaim_bool_exp
  ): [PresaleClaim!]!

  """
  fetch data from the table: "PresaleParticipation"
  """
  PresaleParticipation(
    """distinct select on columns"""
    distinct_on: [PresaleParticipation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PresaleParticipation_order_by!]

    """filter the rows returned"""
    where: PresaleParticipation_bool_exp
  ): [PresaleParticipation!]!

  """
  fetch data from the table: "PresaleParticipation" using primary key columns
  """
  PresaleParticipation_by_pk(id: String!): PresaleParticipation

  """
  fetch data from the table in a streaming manner: "PresaleParticipation"
  """
  PresaleParticipation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PresaleParticipation_stream_cursor_input]!

    """filter the rows returned"""
    where: PresaleParticipation_bool_exp
  ): [PresaleParticipation!]!

  """
  fetch data from the table: "PriceCandle"
  """
  PriceCandle(
    """distinct select on columns"""
    distinct_on: [PriceCandle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [PriceCandle_order_by!]

    """filter the rows returned"""
    where: PriceCandle_bool_exp
  ): [PriceCandle!]!

  """fetch data from the table: "PriceCandle" using primary key columns"""
  PriceCandle_by_pk(id: String!): PriceCandle

  """
  fetch data from the table in a streaming manner: "PriceCandle"
  """
  PriceCandle_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PriceCandle_stream_cursor_input]!

    """filter the rows returned"""
    where: PriceCandle_bool_exp
  ): [PriceCandle!]!

  """
  fetch data from the table: "Role"
  """
  Role(
    """distinct select on columns"""
    distinct_on: [Role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Role_order_by!]

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """
  fetch data from the table: "RoleMember"
  """
  RoleMember(
    """distinct select on columns"""
    distinct_on: [RoleMember_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [RoleMember_order_by!]

    """filter the rows returned"""
    where: RoleMember_bool_exp
  ): [RoleMember!]!

  """fetch data from the table: "RoleMember" using primary key columns"""
  RoleMember_by_pk(id: String!): RoleMember

  """
  fetch data from the table in a streaming manner: "RoleMember"
  """
  RoleMember_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RoleMember_stream_cursor_input]!

    """filter the rows returned"""
    where: RoleMember_bool_exp
  ): [RoleMember!]!

  """
  fetch data from the table: "RolePermission"
  """
  RolePermission(
    """distinct select on columns"""
    distinct_on: [RolePermission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [RolePermission_order_by!]

    """filter the rows returned"""
    where: RolePermission_bool_exp
  ): [RolePermission!]!

  """fetch data from the table: "RolePermission" using primary key columns"""
  RolePermission_by_pk(id: String!): RolePermission

  """
  fetch data from the table in a streaming manner: "RolePermission"
  """
  RolePermission_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RolePermission_stream_cursor_input]!

    """filter the rows returned"""
    where: RolePermission_bool_exp
  ): [RolePermission!]!

  """fetch data from the table: "Role" using primary key columns"""
  Role_by_pk(id: String!): Role

  """
  fetch data from the table in a streaming manner: "Role"
  """
  Role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Role_stream_cursor_input]!

    """filter the rows returned"""
    where: Role_bool_exp
  ): [Role!]!

  """
  fetch data from the table: "Stake"
  """
  Stake(
    """distinct select on columns"""
    distinct_on: [Stake_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Stake_order_by!]

    """filter the rows returned"""
    where: Stake_bool_exp
  ): [Stake!]!

  """fetch data from the table: "Stake" using primary key columns"""
  Stake_by_pk(id: String!): Stake

  """
  fetch data from the table in a streaming manner: "Stake"
  """
  Stake_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Stake_stream_cursor_input]!

    """filter the rows returned"""
    where: Stake_bool_exp
  ): [Stake!]!

  """
  fetch data from the table: "StakingContract"
  """
  StakingContract(
    """distinct select on columns"""
    distinct_on: [StakingContract_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [StakingContract_order_by!]

    """filter the rows returned"""
    where: StakingContract_bool_exp
  ): [StakingContract!]!

  """fetch data from the table: "StakingContract" using primary key columns"""
  StakingContract_by_pk(id: String!): StakingContract

  """
  fetch data from the table in a streaming manner: "StakingContract"
  """
  StakingContract_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [StakingContract_stream_cursor_input]!

    """filter the rows returned"""
    where: StakingContract_bool_exp
  ): [StakingContract!]!

  """
  fetch data from the table: "Token"
  """
  Token(
    """distinct select on columns"""
    distinct_on: [Token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Token_order_by!]

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """fetch data from the table: "Token" using primary key columns"""
  Token_by_pk(id: String!): Token

  """
  fetch data from the table in a streaming manner: "Token"
  """
  Token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Token_stream_cursor_input]!

    """filter the rows returned"""
    where: Token_bool_exp
  ): [Token!]!

  """
  fetch data from the table: "Trade"
  """
  Trade(
    """distinct select on columns"""
    distinct_on: [Trade_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Trade_order_by!]

    """filter the rows returned"""
    where: Trade_bool_exp
  ): [Trade!]!

  """fetch data from the table: "Trade" using primary key columns"""
  Trade_by_pk(id: String!): Trade

  """
  fetch data from the table in a streaming manner: "Trade"
  """
  Trade_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Trade_stream_cursor_input]!

    """filter the rows returned"""
    where: Trade_bool_exp
  ): [Trade!]!

  """
  fetch data from the table: "Treasury"
  """
  Treasury(
    """distinct select on columns"""
    distinct_on: [Treasury_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Treasury_order_by!]

    """filter the rows returned"""
    where: Treasury_bool_exp
  ): [Treasury!]!

  """fetch data from the table: "Treasury" using primary key columns"""
  Treasury_by_pk(id: String!): Treasury

  """
  fetch data from the table in a streaming manner: "Treasury"
  """
  Treasury_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Treasury_stream_cursor_input]!

    """filter the rows returned"""
    where: Treasury_bool_exp
  ): [Treasury!]!

  """
  fetch data from the table: "UserMarketPosition"
  """
  UserMarketPosition(
    """distinct select on columns"""
    distinct_on: [UserMarketPosition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [UserMarketPosition_order_by!]

    """filter the rows returned"""
    where: UserMarketPosition_bool_exp
  ): [UserMarketPosition!]!

  """
  fetch data from the table: "UserMarketPosition" using primary key columns
  """
  UserMarketPosition_by_pk(id: String!): UserMarketPosition

  """
  fetch data from the table in a streaming manner: "UserMarketPosition"
  """
  UserMarketPosition_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserMarketPosition_stream_cursor_input]!

    """filter the rows returned"""
    where: UserMarketPosition_bool_exp
  ): [UserMarketPosition!]!

  """
  fetch data from the table: "chain_metadata"
  """
  chain_metadata(
    """distinct select on columns"""
    distinct_on: [chain_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chain_metadata_order_by!]

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """fetch data from the table: "chain_metadata" using primary key columns"""
  chain_metadata_by_pk(chain_id: Int!): chain_metadata

  """
  fetch data from the table in a streaming manner: "chain_metadata"
  """
  chain_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chain_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: chain_metadata_bool_exp
  ): [chain_metadata!]!

  """
  fetch data from the table: "dynamic_contract_registry"
  """
  dynamic_contract_registry(
    """distinct select on columns"""
    distinct_on: [dynamic_contract_registry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_contract_registry_order_by!]

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "dynamic_contract_registry" using primary key columns
  """
  dynamic_contract_registry_by_pk(id: String!): dynamic_contract_registry

  """
  fetch data from the table in a streaming manner: "dynamic_contract_registry"
  """
  dynamic_contract_registry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [dynamic_contract_registry_stream_cursor_input]!

    """filter the rows returned"""
    where: dynamic_contract_registry_bool_exp
  ): [dynamic_contract_registry!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data(
    """distinct select on columns"""
    distinct_on: [end_of_block_range_scanned_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [end_of_block_range_scanned_data_order_by!]

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "end_of_block_range_scanned_data" using primary key columns
  """
  end_of_block_range_scanned_data_by_pk(block_number: Int!, chain_id: Int!): end_of_block_range_scanned_data

  """
  fetch data from the table in a streaming manner: "end_of_block_range_scanned_data"
  """
  end_of_block_range_scanned_data_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [end_of_block_range_scanned_data_stream_cursor_input]!

    """filter the rows returned"""
    where: end_of_block_range_scanned_data_bool_exp
  ): [end_of_block_range_scanned_data!]!

  """
  fetch data from the table: "event_sync_state"
  """
  event_sync_state(
    """distinct select on columns"""
    distinct_on: [event_sync_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_sync_state_order_by!]

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "event_sync_state" using primary key columns
  """
  event_sync_state_by_pk(chain_id: Int!): event_sync_state

  """
  fetch data from the table in a streaming manner: "event_sync_state"
  """
  event_sync_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [event_sync_state_stream_cursor_input]!

    """filter the rows returned"""
    where: event_sync_state_bool_exp
  ): [event_sync_state!]!

  """
  fetch data from the table: "persisted_state"
  """
  persisted_state(
    """distinct select on columns"""
    distinct_on: [persisted_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [persisted_state_order_by!]

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """fetch data from the table: "persisted_state" using primary key columns"""
  persisted_state_by_pk(id: Int!): persisted_state

  """
  fetch data from the table in a streaming manner: "persisted_state"
  """
  persisted_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [persisted_state_stream_cursor_input]!

    """filter the rows returned"""
    where: persisted_state_bool_exp
  ): [persisted_state!]!

  """
  fetch data from the table: "raw_events"
  """
  raw_events(
    """distinct select on columns"""
    distinct_on: [raw_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [raw_events_order_by!]

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!

  """fetch data from the table: "raw_events" using primary key columns"""
  raw_events_by_pk(serial: Int!): raw_events

  """
  fetch data from the table in a streaming manner: "raw_events"
  """
  raw_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [raw_events_stream_cursor_input]!

    """filter the rows returned"""
    where: raw_events_bool_exp
  ): [raw_events!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar tradetype

"""
Boolean expression to compare columns of type "tradetype". All fields are combined with logical 'AND'.
"""
input tradetype_comparison_exp {
  _eq: tradetype
  _gt: tradetype
  _gte: tradetype
  _in: [tradetype!]
  _is_null: Boolean
  _lt: tradetype
  _lte: tradetype
  _neq: tradetype
  _nin: [tradetype!]
}